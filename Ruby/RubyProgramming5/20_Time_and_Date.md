# 第 20 章 Time 类与Date 类
---

[TOC]

## 20.1 Time 类与Date 类
Time 类用于表示时间。时间除了表示年月日时分秒的信息以外，还包含表示地域时差的时区（time zone）信息。例如我们可以计算中国当前时间是国际协调时间的几点。
Date 类只用于表示年月日，是以天为单位进行计算的。 Date 类还可以求下个月的同一天、本月末等日期。
Time 类与 Date 类表示时间、日期时并没有什么特别限制（前提是现在的日历能一直用下去，甚至“西历100 亿年”这样的时间、日期也都可以表示）。但实际上文件的时间戳、程序的运行时间等系统内的时间，以及数据库中的时间类型数据等，有时会受到执行环境的限制。

## 20.2 获取时间
- `Time.new`, `Time.now`：通过 Time.new 方法或者 Time.now 方法获取表示当前时间的 Time 对象。
- `t.year`, `t.month`, `t.day`：也可以获取时间对象中的年、月、日。

  时间的相关方法
    | 方法名 | 意义 |
    | -- | -- |
    | year | 年 |
    | month | 月 |
    | day | 日 |
    | hour | 时 |
    | min | 分 |
    | sec | 秒 |
    | usec | 秒以下的位数（以微秒为单位） |
    | nsec | 秒以下的位数（以纳秒为单位） |
    | to_i | 从1970 年1 月1 日到当前时间的秒数 |
    | wday | 一周中的第几天（0 表示星期天） |
    | mday | 一个月中的第几天（与d ay 方法一样） |
    | yday | 一年中的第几天（1 表示1 月1 日） |
    | zone | 时区（ "JST" 等） |
    | utc_offset | 与UTC 的时差（以秒为单位） |

- `Time.mktime(year[, month[, day[ , hour[ , min[, sec[, usec]]]]]])`：通过 Time.mktime 方法可以根据指定时间获取 Time 对象。
- `Time.at(epoch)`：通过Time.at 方法可以获取自Unix 系统的标准时间 1970 年 1 月 1 日凌晨 0 时 0 分 0 秒（UTC）之后经过的秒数所对应的 Time 对象。
> **关联**：文件的创建时间、更新时间等也都能以 Time 对象的形式获取。详情请参考18.3 节。

## 20.3 计算时间
Time 对象之间可以互相比较、运算。
```ruby
t1 = Time.now
sleep(10)      # 等待10 秒
t2 = Time.now
p t1 < t2      #=> true
p t2 - t1      #=> 10.004440506
```
还可以增加或减少 Time 对象的秒数。
```ruby
t = Time.now
p t                    #=> 2015-09-25 02:55:40 +0900
t2 = t + 60 * 60 * 24  #=> 增加24 小时的秒数
p t2                   #=> 2015-09-26 02:55:40 +0900
```

## 20.4 时间的格式
- `t.strftime(format)`, `t.to_s`：通过 Time#strftime 方法可以把时间转换为遵循某种格式的字符串。下表为格式（format）中可以使用的字符串：
    | 格式 | 意义与范围 |
    | -- | -- |
    | %A | 星期的名称（S unday、 M onday… …） |
    | %a | 星期的缩写名称（S un、 M on… …） |
    | %B | 月份的名称（J anuary、 F ebruary… …） |
    | %b | 月份的缩写（J an、 F eb… …） |
    | %c | 日期与时间 |
    | %d | 日（01 ～ 31） |
    | %H | 24 小时制（00 ～ 23） |
    | %I | 12 小时制（01 ～ 12） |
    | %j | 一年中的天（001 ～ 366） |
    | %M | 分（00 ～ 59） |
    | %m | 表示月的数字（01 ～ 12） |
    | %p | 上午或下午（AM、PM） |
    | %S | 秒（00 ～ 60） ※60 表示闰秒。 |
    | %U | 表示周的数字。以星期天为一周的开始（00 ～ 53） |
    | %W | 表示周的数字。以星期一为一周的开始（00 ～ 53） |
    | %w | 表示星期的数字。0 表示星期天（0 ～ 6） |
    | %X | 时间 |
    | %x | 日期 |
    | %Y | 表示西历的数字 |
    | %y | 西历的后两位（00 ～ 99） |
    | %Z | 时区（ JST 等） |
    | %z | 时区（+0900 等） |
    | %% | 原封不动地输出 % |
  例如， Time#to_s 方法得到的字符串格式与 `%Y-%m-%d %H:%M:%S %z` 是等价的。

  > **备注**：Time#strftime 方法的格式是与平台相关的，不同平台下的执行结果可能不一样。例如，在Windows 中， "%Z" 的执行结果会显示" 中国标准时间"。

- `t.rfc2822`
通过 Time#rfc2822 方法可以生成符合电子邮件头部信息中的Date ：字段格式的字符串。在互联网的相关文档RFC（Request For Comments）中，有一个关于电子邮件形式定义的RFC 2822 文档， rfc2822 这个方法名就来自于此。使用这个方法前，需要预先通过 require "time" 引用 time 库。
  ```ruby
  require "time"
  t = Time.now
  p t.rfc2822 #=> "Fri, 25 Sep 2015 02:55:40 +0900"
  ```
- `t.iso8601`：通过 Time#iso8601 方法生成符合ISO 8601 国际标准的时间格式的字符串。使用这个方法时也需要引用 time 库。
  ```ruby
  require "time"
  t = Time.now
  p t.iso8601    #=> "2015-09-25T02:55:40+09:00"
  ```

## 20.5 本地时间
世界各地都有时差。大家的计算机中也设有时区，一般计算机中的时间都是根据时区来设定的。
- `t.utc`, `t.localtime`：我们可以用 Time#utc 方法把 Time 对象的时区变更为国际协调时间（UTC）。反之，用 Time#localtime 方法则可以把UTC 变更为本地时间。
```ruby
t = Time.now
p t #=> 2015-09-25 02:55:40 +0900
t.utc
p t #=> 2015-09-24 17:55:40 UTC
t.localtime
p t #=> 2015-09-25 02:55:40 +0900
```
从上面的例子可以知道，上述方法都具有破坏性，都会改变Time 对象。如果需要没有破坏性的版本，请使用 getutc 方法和 getlocal 方法。

## 20.6 从字符串中获取时间
可以将以字符串形式表示的时间转换为 Time 对象。

- `Time.parse(str)`
通过 require "time"， 就可以使用T ime.parse 方法来操作以字符串形式表示的时间。 Time.parse 方法会解析参数字符串str，返回对应的 Time 对象。
Time.parse 方法除了可以返回与 Time#to_s 方法相同的格式，还可以返回"yyyy/mm/dd"等多种格式。
```ruby
require "time"
　
p Time.parse("Fri Sep 25 02:45:15 UTC 2015")
#=> 2015-09-25 02:45:15 UTC
p Time.parse("Fri, 25 Sep 2015 02:45:15 +0900")
#=> 2015-09-25 02:45:15 +0900
p Time.parse("2015/09/25")
#=> 2015-09-25 00:00:00 +0900
p Time.parse("2015/09/25 02:45:15")
#=> 2015-09-25 02:45:15 +0900
p Time.parse("H27.9.25")
#=> 2015-09-25 00:00:00 +0900
```

- `Time.strptime(str, format)`
程序无法自动转换所有表示日期的字符串，比如Time.parse 方法无法处理“平成 27 年 9 月1 日”，又比如像美式时间格式“9/1/2015”或英式时间格式“1/9/2015”这样，无法从表面直接判断正确的日期。此时，可以使用strptime 方法指定格式把日期匹配出来。

strptime 方法的格式与strftime 方法的格式相同。而且还可以指定块，这时会把匹配到的年份传入块，这样就可以把年号纪年改为西历纪年或两位数纪年。
```ruby
require "time"
p Time.strptime(" 平成27 年9 月1 日", " 平成%Y 年%m 月%d 日") do |y|
  y + 1988
end
    #=> 2015-09-01 00:00:00 +0900
p Time.strptime("9/1/2015", "%m/%d/%Y")
    #=> 2015-09-01 00:00:00 +900
p Time.strptime("1/9/2015", "%d/%m/%Y")
    #=> 2015-09-01 00:00:00 +900
```

## 20.7 获取日期
Date 类用于处理不包含时间的日期。使用 Date.today 方法可以得到表示当前日期的 Date 对象。使用 Date 类需要引用 date 库。
```ruby
require "date"
d = Date.today
puts d #=> 2015-09-25
```
与Time 类一样，能够求得构成日期的要素。
```ruby
require "date"
d = Date.today
p d.year # 年 => 2015
p d.month # 月 => 9
p d.day # 日 => 25
p d.wday # 一周中的第几天（0 表示星期天） => 5
p d.mday # 一个月中的第几天（与day 方法一样） => 25
p d.yday # 一年中的第几天（1 表示1 月1 日） => 268
　　还可以指定日期生成 Date 对象。
require "date"
d = Date.new(2015, 9, 25)
puts d #=> 2015-09-25
```

Date 类有一个特点：可以对月末的日期做 -1 处理（ -2 表示月末的前一天）。当然也可以应对闰年。
```ruby
require "date"
d = Date.new(2015,2,-1)
puts d #=> 2015-02-28
d = Date.new(2016, 2, -1)
puts d #=> 2016-02-29
```

通过使用 >> 运算符，就可以获取表示下一个月相同日期的 Date 对象。同理，使用 << 运算符得到的是表示前一个月相同日期的 Date 对象。如果该月中没有相同的日期（例如 2月31日），则会返回月末的日期。
```ruby
require "date"
d = Date.new(2016, 1, 31)
puts d #=> 2016-01-31
puts d >> 1 #=> 2016-02-29
puts d >> 2 #=> 2016-03-31
puts d << 1 #=> 2015-12-31
puts d << 2 #=> 2015-11-30
```

## 20.8 计算日期
Date 对象之间的计算以天为单位。因此， Date 对象之间进行减法运算时，返回的是两者之间的天数。日期减法运算的结果不是整数，而是 Rational 对象。此外，还可以将 Date 对象与整数进行加法、减法等运算，这时会返回该对象前后的日期。
```ruby
require "date"
d1 = Date.new(2015, 1, 1)
d2 = Date.new(2015, 1, 4)
puts d2 - d1       #=> 3/1
d = Date.today
puts d             #=> 2015-09-25
puts d + 1         #=> 2015-09-26
puts d + 100       #=> 2016-01-03
puts d - 1         #=> 2015-09-24
puts d -100        #=> 2015-06-17
```

## 20.9 日期的格式
与 Time 类一样，通过 strftime 方法也可以将日期按指定的格式转换为字符串，但结果中时间的部分会全部变为0。此外，还可以使用iso8601 方法和to_s 方法。
```ruby
require "date"
t = Date.today
p t.strftime("%Y/%m/%d %H:%M:%S")
#=> "2015/09/25 00:00:00"
p t.strftime("%a %b %d %H:%M:%S %Z %Y")
#=> "Fri Sep 25 00:00:00 +00:00 2015"
p t.iso8601 #=> "2015-09-25"
p t.to_s #=> "2015-09-25"
```

## 20.10 从字符串中获取日期
使用 Date.parse 方法可以将字符串转换为日期。这个方法可以应对多种日期格式。
```ruby
require "date"
putsDate.parse("Fri Sep 25 03:50:12 JST 2015") #=> 2015-09-25
putsDate.parse("H27.09.25") #=> 2015-09-25
putsDate.parse("S48.9.28") #=> 1973-09-28
putsDate.parse("25/9/2015", "%d/%m/%Y") #=> 2015-09-25
```

## 20.11 Time 与Date 的互相转换.
可以使用to_time 方法和to_date 方法互相转换Time 对象和Date 对象。由于Date 对象没有时间部分，因此转换后时间部分会显示系统时区的 0 点 0 分 0 秒。
```ruby
require "date"
t1 = Time.now
p t1 #=> 2015-09-25 05:46:15 +0900
d = t1.to_date
puts d #=> 2015-09-25
t2 = d.to_time
p t2 #=> 2015-09-25 00:00:00 +0900
```

### 专栏：关于GC
在第 3 部分中我们介绍了各种类型的对象，而在程序中生成这些对象（一部分除外）时都会消耗内存空间。例如数组、字符串等，如果长度变大了，那么它们需要的内存空间也会随之变大。程序为了能正常运行不可避免地要创建对象，但是计算机的内存空间却不是可以无限使用的，因此就必须释放已经不需要的对象所占用的内存空间。

下面的写法在本书中已经出现过多次，这里变量 line 引用的字符串，在下一次读取时就不能再被引用了。
```ruby
io.each_line do |line|
print(line)
end
```
还有，在方法执行完毕后，在方法中临时生成的对象也不再需要了。
```ruby
def hello(name)
msg = "Hello, #{name}" #=> 创建新的字符串对象
puts(msg)
end
```

但是，释放内存空间并不是大部分程序主要关心的功能，而且忘记释放内存，或者误把正在使用的对象释放等，都很有可能引起难缠的程序漏洞。因此，在 Ruby（Java、Perl、Lisp 等语言也都具备这样的功能）中，解析器（interpreter）会在适当的时机释放已经没有被任何地方引用的对象所占用的资源。这样的功能称为Garbage Collection（垃圾回收），简称GC。

有了GC 后，我们就无需再为内存管理而烦恼了。GC 是支撑Ruby 的宗旨——快乐编程的重要功能之一。
