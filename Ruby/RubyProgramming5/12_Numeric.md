# 第12章 数值类
---

[TOC]

## 12.1 数值类的构成



程序中用到的整数一般都是 Fixnum 类能够处理的范围内的整数。如果使用的整数超过了 Fixnum 的范围，Ruby 就会自动将其转换为 Bignum 类。因此，在写程序时，我们几乎可以忽略上述整数类的区别。

Ruby 也可以处理有理数和复数。有理数用 Rational 类表示，复数用 Complex 类表示。

Rational 对象用“Rational( 分子, 分母)”的形式定义，我们还可以使用 to_f 方法将其转换为 Float 对象；还可以使用numerator 方法和denomination 方法获取Rational 对象的分子和分母。
```ruby
# 计算 2/5 + 1/3.
a = Rational(2, 5)
b = Rational(1, 3)
p [a,b]                          #=> [(2/5),(1/3)]
c = a + b
p c                              #=> (11/15)
p c.to_f                         #=> 0.7333333333333333
p [c.numerator, c.denominator]   #=> [11, 15]
```

Complex 对象用“Complex( 实数, 虚数)”的形式定义。以下是计算复数1+2i 的2 次幂的例子。我们可以使用 real 方法和 imaginary 方法获取 Complex 对象的实数与虚数。
```ruby
c = Complex(1, 2) ** 2
p c                       #=> (-3+4i)
p [c.real, c.imaginary]   #=> [-3, 4]
```

## 12.2 数值的字面量
下表是表示数值对象的字面量的例子。
| 字面量 | 作用（括号内为10进制的值） |
| -- | -- |
| 123 | 表示十进制整数 |
| 0123 | 表示八进制整数（83） |
| 0o123 | 表示八进制整数（83） |
| 0d123 | 表示十进制整数（123） |
| 0x123 | 表示十六进制整数（291） |
| 0b1111011 | 表示二进制整数（123） |
| 123.45 | 浮点小数 |
| 1.23e4 | 浮点小数的指数表示法（1.23×10 的4 次幂= 12300.0） |
| 1.23e-4 | 浮点小数的指数表示法（1.23×10 的-4 次幂= 0.000123） |
| 123r | 有理数的(123/1) |
| 123.45r | 有理数的123.45（12345/100 = 2469/20） |
| 123i | 虚数的123i |
| 123.45i | 虚数的123.45i |

单纯的数字罗列表示十进制整数。以 0b 开头的数值表示二进制数，以 0 或者 0o 开头的数值表示八进制数，以 0d 开头的数值表示十进制数，以 0x 开头的数值表示十六进制数。字面量中的 `_` 会被自动忽略。因此，在使用每 3 位数字间隔一下这样的数值表示方法时会十分方便。
```ruby
p 1234567      #=> 1234567
p 1_234_567    #=> 1234567
p 0b11111111   #=> 255
p 01234567     #=> 342391
p 0x12345678   #=> 305419896
```

包含小数点的数值为浮点小数。我们还可以采用有效数字与指数配合的科学计数法来表示浮
点小数。格式为“有效数字” +“ 英文字母e（或者E）” +“ 表示指数的整数”。
```ruby
p 1.234      #=> 1.234
p 1.234e4    #=> 12340.0
p 1.234e-4   #=> 0.0001234
```
此外，在整数和小数的末尾添加 r 可以得到Rational 对象，添加 i 可以得到Complex对象。

## 12.3 算数计算

下表列出了数值对象间进行基本的算术运算时用到的运算符：
| 运算符 | 运算 |
| -- | -- |
| + | 加法运算 |
| - | 减法运算 |
| * | 乘法运算 |
| / | 除法运算 |
| % | 取余运算 |
| ** | 乘方运算 |

Integer 对象与 Float 对象的运算结果为 Float 对象。 Integer 对象之间、 Float 对象之间的运算结果分别为 Integer 对象、 Float 对象。

```ruby
r = (2 / 5r) + (1 / 3r)
p r          #=> (11/15)
p r.to_f          #=> 0.7333333333333333
c = (1 + 2i) ** 2
p c            #=> (-3+4i)
```
需要注意的是，指数为负整数的乘方运算返回的结果是表示有理数的 Rational 对象。

### 除法
除了 `/` 和 `%` 以外，数值对象中还有一些与除法相关的方法。

- `x.div(y)`：返回 x 除以 y 后的商的整数
- `x.quo(y)`：返回x 除以y 后的商，如果x、y 都是整数，则返回Rational 对象
- `x.modulo(y)`：与 x % y 等价。
- `x.divmod(y)`：将x 除以y 后的商和余数作为数组返回。
- `x.remainder(y)`：返回 x 除以y 的余数，结果的符号与x 的符号一致。

除数为0 时，Integer 类会返回错误，而 Float 类则会返回 Infinity （无限大）或者 NaN （Not a Number）。如果再用这两个值进行运算，那么结果只会返回 Infinity 或者NaN。把输入的数据直接用于运算时，除数有可能会为 0，我们应当注意避免这样的情况发生。

## 12.4 Math 模块
Math 模块提供了三角函数、对数函数等常用的函数运算的方法。该模块中定义了模块函数和常量。

| 方法名 | 作用 |
| -- | -- |
| acos(x) | 反余弦函数 |
| acosh(x) | 反双曲余弦函数 |
| asin(x) | 反正弦函数 |
| asinh(x) | 反双曲正弦函数 |
| atan(x) | 反正切函数 |
| atan2(x, y) | 表示4 个象限的反正切函数 |
| atanh(x) | 反双曲正切函数 |
| cbrt(x) | 立方根 |
| cos(x) | 余弦函数 |
| cosh(x) | 双曲余弦函数 |
| erf(x) | 误差函数 |
| erfc(x) | 余补误差函数 |
| exp(x) | 指数函数 |
| frexp(x) | 把一个浮点数分解为尾数和指数 |
| gamma(x) | 伽玛函数 |
| hypot(x, y) | 计算三角形的斜边长度 |
| ldexp(x, y) | 返回x 乘以2 的y 次幂的值 |
| lgamma(x) | 伽玛函数的自然对数 |
| log(x) | 底数为 e 的对数（自然对数） |
| log10(x) | 底数为 10 的对数（常用对数） |
| log2(x) | 底数为 2 的对数 |
| sin(x) | 正弦函数 |
| sinh(x) | 双曲正弦函数 |
| sqrt(x) | 平方根 |
| tan(x) | 正切函数 |
| tanh(x) | 双曲正切函数 |

| 常量名 | 作用 |
| -- | -- |
| PI | 圆周率（3.141592653589793） |
| E | 自然对数的底数（2.718281828459045） |

## 12.5 数值类型转换
将 Integer 对象转换为 Float 对象时，可以使用 to_f 方法。相反，使用 to_i 方法则可以将Float 对象转换为Integer 对象（Integer#to_i 方法和 Float#to_f 方法返回与接收者一样的值）。另外，也可以把字符串转换为数值。

Float#to_i 方法返回的结果会把小数点以后的值去掉。我们用 round 方法对小数进行四舍五入的处理。可以用参数指定取几位小数，如果参数为负数，则往小数点左边（即整数部分）的位数取整。
```ruby
p 0.12.round(1)   #=> 0.1
p 0.18.round(1)   #=> 0.2
p 1.2.round       #=> 1
p 1.8.round       #=> 2
p 120.round(-2)   #=> 100
p 180.round(-2)   #=> 200
```

返回比接收者大的最小整数用 ceil 方法，返回比接收者小的最大整数用 floor 方法。我们还可以将数值转换为 Rational 对象和 Complex 对象，分别使用 to_r 和 to_c 方法。

## 12.6 位运算
Interger 类可以进行如下所示的位运算：

| 运算符 | 运算 |
| -- | -- |
| ~ | 按位取反（一元运算符） |
| & | 按位与 |
| \| | 按位或 |
| ^ | 按位异或 ((a&~b|~a&b)) |
| \>\> | 位右移 |
| << | 位左移 |

位运算就是对以二进制形式表现的整数的每个二进制位进行的操作和运算。通过使用二进制的数值字面量，或者用printf 方法输出二进制数，可以使位运算中的值和结果更容易理解。

### 专栏：位与字节
在计算机的世界中，我们经常会接触到“位”与“字节”：
- **位**：位（bit）是计算机中最小的数据单位，表示ON 或OFF，或者0 或1。据说bit 原本是“binary digit”的简称。
- **位与二进制**：虽然位中只包含两种信息，但将位的信息两两组合的话，就可以表示 00、01、10、11这4 种信息。同样，3 位一组的话可以表示 8 种信息，4 位一组的话可以表示 16 种信息。随着位的数量的增加，可以表示的信息的数量也会成倍地增加。
- **八进制与十六进制**：计算机处理的信息是用二进制表示的，但是如果全部都用0、1 来表示，位数就会变得非常大，不便于理解，因此可以使用八进制和十六进制来解决这个问题。
- **字节**：计算机在表示数的时候，会把一定数量的位（bit）的组合，即字节（byte）作为计数单位。1 个字节有多少位并没有通用的标准。在以前，根据制造商和机种的不同，1 个字节包含的位的数量也不一样，但现在1 个字节有 8 位已经是业界常识了。1 个字节可以表示的十进制数是从0 到 255，八进制数是从 000 到 377，十六进制数是从 00 到 FF 。由于 2 个十六进制位刚好等于 8 位（1 个字节），因此用十六进制来表示以字节为单位的数据会非常方便。

## 12.7 随机数
有时候随机性可能会帮助我们解决一些问题，随机性一般有以下特质。
- 没有规则和法则依据
- 一定范围内的数会均等地出现

我们可以用 Random.rand 方法得到随机数。不指定参数时， Random.rand 方法返回比 1 小的浮点小数。参数为正整数时，返回 0 到该正整数之间的数值。

程序不能生成真正的随机数，只能通过某种算法生成看起来像随机数的值，这样的随机数称为**伪随机数**。生成伪随机数需要以某个值为基础，这个值称为随机数的种子。伪随机数终究只是通过计算得到的数值，只要随机数的种子一样，那么得到的值就有可能重复出现。使用 Random.new 方法初始化随机数生成器，然后再使用 Random#rand 方法，就可以对 Random 对象指定随机数种子，从而生成随机数。
```ruby
r1 = Random.new(1)    # 初始化随机数组
p [r1.rand, r1.rand]  #=> [0.417022004702574, 0.7203244934421581]
r2 = Random.new(1)    # 再次初始化随机数组
p [r2.rand, r2.rand]  #=> [0.417022004702574, 0.7203244934421581]
```
Random.new 方法不指定参数的情况下，则会用随机生成的随机数种子初始化 Random 对象，因此每次得到的随机数组也会不一样。

在信息安全领域中，密码、加密key 等会用到随机数。Ruby 的securerandom 库就是为了满足这种需求而准备的。这个库中有一个SecureRandom.random_bytes 方法，把字节数作为参数传过去后，会返回长度随机的一组字节（String 对象）。

随机的字节组中有时会包含无法作为字符显示的值而导致无法直接操作。SecureRandom.base64 方法的返回值是英文和数字的组合，我们可以根据不同的需求选择不同的方法。
```ruby
require "securerandom"
p SecureRandom.random_bytes(12) #=> "\x0FLz\xEE\x809F\x81\x80\xC3\x14\t"
p SecureRandom.base64(12)       #=> "xEn6NEZi9MO9xt/k"
```

## 12.8 计数
除了数值计算外， Integer 类还能计算处理的次数、数组的元素个数等。接下来介绍的方法就是按照数值指定的次数执行循环处理的迭代器。

- `n.times{|i| … }`：循环n 次，从0 到n-1 的值会被依次赋值给块变量i。
- `from.upto(to){|i| … }`：从 from 开始循环对 i 进行加1 处理，直到 i 等于 to。
- `from.downto(to){|i|…}`：从 from 开始循环对 i 进行减1 处理，直到 i 等于 to。
- `from.step(to, step){|i|…}`：从 from 开始循环对 i 进行加 step 处理，直到 i 等于 to。

> 说明：以上方法在 from 无法到达 to 的情况下均不会执行循环处理，即：
- upto 在 from 比 to 大时不会执行循环处理。downto 在 from 比 to 小时不会执行循环处理。
-  step 在 step 为正的情况下，from 比 to 大时不会执行循环处理。step 为负的情况下，from 比 to 小时不会执行循环处理。

如果不对 times、 upto、 downto、 step 的各方法指定块，则会返回 Enumerator 对象。这样，之前通过 step 方法的块获取的一连串数值，就同样也可以通过 Enumerator#collect 方法获取。
> 引用：关于 Enumerator 对象，我们会在第14 章中介绍。

## 12.9 近似值误差
处理浮点小数时很容易因误差产生问题。
```ruby
a = 0.1 + 0.2
b = 0.3
p [a, b]    #=> [0.30000000000000004, 0.3]
p a = = b   #=> false
```
计算机在处理 1/5、1/3 这种用二进制无法正确表示的数值时，结果就会产生误差。而如果要用二进制的和来表示这类数值，就必须在适当的位置截断计算结果，这样就产生了近似值误差。

如果可以把小数转换为两个整数相除的形式，那么通过使用 Rational 类进行运算，就可以避免近似值误差。另外，Ruby 还提供了 bigdecimal 库，可以有效处理拥有更多小数位的十进制数。
```ruby
a = 1 / 10r + 2 / 10r
b = 3 / 10r
p [a, b]   #=> [(3/10), (3/10)]
p a == b   #=> true
```
### Comparable 模块
Ruby 的比较运算符（ = = 、 <= 等）实际上都是方法。 Comparable 模块中封装了比较运算符，将其Mix-in 到类后，就可以实现对实例进行比较的方法（下表）。Comparable 在英语中就是“可以比较”的意思。

Comparable模块封装了<，<=，==，>=，>，between? 方法

下面的 Vector 类表示拥有 x 和 y 两个坐标的向量。为了比较向量间的坐标，这里定义了 <=> 运算符。然后，通过包含（include） Comparable 模块，就可以实现上表中的比较方法。
```ruby
class Vector
include Comparable
attr_accessor :x, :y
def initialize(x, y)
@x, @y = x, y
end
def scalar
Math.sqrt(x ** 2 + y ** 2)
end
def <=> (other)
scalar <=> other.scalar
end
end
v1 = Vector.new(2, 6)
v2 = Vector.new(4, -4)
p v1 <=> v2 #=> 1
p v1 < v2 #=> false
p v1 > v2 #=> true
```
在本书介绍过的类中，Numeric、 String、 Time 都包含了 Comparable 模块。
