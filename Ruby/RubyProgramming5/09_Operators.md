# 第09章 运算符
---

[TOC]

## 9.1 赋值运算符
Ruby 的变量是在首次赋值时创建的，之后，程序可以对变量引用的对象进行各种各样的处理，设置再次赋值。

将二元运算符与赋值组合起来的运算符称为**赋值运算符**。常用赋值运算符如下：

| 常用赋值运算符 | | | | | | |
| -- | -- | -- | -- | -- | -- | -- |
| `&&=` | `\|\|=` | `^=` | `&=` | `\|=` | `<<=` | `>>=` |
| `+=` | `-=` | `*=` | `/=` | `%=` | `**=` | |

## 9.2 逻辑运算符的应用
逻辑运算符具有以下特征：
- 表达式的执行顺序是从左到右
- 如果逻辑表达式的真假已经可以确定，则不会再判断剩余的表达式
- 最后一个表达式的值为整体逻辑表达式的值

在使用 `条件1 || 条件2` 或 `条件1 && 条件2` 的时候，Ruby 会避免无谓的判断，只在尚需要进一步判断的情况下才会继续执行判断。

如果某些参数为 nil ，则读取其方法或值时就会产生程序错误。像这样的程序，通过使用 `&&`， 只要下面1行代码就可以搞定了。
```ruby
item = ary && ary.first
```

我们可以使用 `对象&.方法` 的写法进一步简化代码，这种写法又叫**安全运算符**（safe navigation operato）或**nil检查方法调用**。仅当对象的值不是 nil 时才会进一步调用方法，如果对象为 `nil` 则表达式的值为 `nil`。
```ruby
item = ary&.first
```

同样的，我们还可以使用 `||=` 写法，`var ||= 1` 表示 `var = var || 1`，只有在var为false或nil时，才把1赋给var，这是给变量定义默认值的常用写法。

## 9.3 条件运算符
除了逻辑运算符，还有专门描述条件分支的运算符。条件运算符 `? =` 的用法如下：
```ruby
条件 ? 表达式1 : 表达式2
```
上面的表达式等价于如下 if 语句表达式：
```ruby
if 条件
  表达式1
else
  表达式2
end
```
这样的写法比较简洁，但如果表达式过于复杂就会使程序变得难懂，因此建议不要滥用此写法。条件运算符也称为**三元运算符**。

## 9.4 范围运算符
在Ruby 中有表示数值范围的范围（range）对象，例如可以使用 `Range.new(1, 10)` 表示 1 到 10 的范围对象。用**范围运算符**可以简化范围对象的定义：`1..10`

范围运算符有 `..` 和 `...` 两种。x .. y 和 x ... y 的区别在于，前者的范围是从x 到 y，而后者的范围则是从x 到 y 的前一个元素。我们可以用 `to_a` 方法来确认一下 .. 和 ... 有什么不同， to_a 方法会返回范围中从开始到结束的值。
```ruby
p (5..10).to_a #=> [5, 6, 7, 8, 9, 10]
p (5...10).to_a #=> [5, 6, 7, 8, 9]
```

如果数值以外的对象也实现了根据当前值生成下一个值的方法，那么通过指定范围的起点与终点就可以生成 Range 对象。例如，我们可以用字符串对象生成 Range 对象:
```ruby
p ("a".."f").to_a #=> ["a", "b", "c", "d", "e", "f"]
p ("a"..."f").to_a #=> ["a", "b", "c", "d", "e"]
```

在 Range 对象内部，可以使用 succ 方法根据起点值逐个生成接下来的值。具体来说就是，对 succ 方法的返回值调用 succ 方法，然后对该返回值再调用 succ 方法……直到得到的值比终点值大时才结束处理。

## 9.5 运算符的优先级

运算符按优先级自高到低有如下顺序：

| 运算符 |
| -- |
| `::` |
| `[]` |
| `+ （一元运算符） ! ~` |
| `**` |
| `- （一元运算符）`  |
| `* / %` |
| `+ -` |
| `<< >>` |
| `&` |
| `\| ^` |
| `> >= < <=` |
| `<=> == === != =~ !~` |
| `&&` |
| `\|\|` |
| `?: （条件运算符）`| 
| `.. ...` |
| `= （包含+= -= *= /=等）` |
| `not` |
| `and or` |
如果不想按照优先级的顺序进行计算，可以用 `()` 将希望优先计算的部分括起来，当有多个 `()` 时，则从最内侧的 `()` 开始算起。

## 9.6 定义运算符
Ruby 的运算符大多都是作为实例方法提供给我们使用的，因此我们可以很方便地定义或者
重定义运算符，改变其原有的含义。但有以下运算符不能重定义：

| 不能重定义的运算符 | | | | | | | | | |
| -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |
| `::` | `&&` |  `\|\|` | `..` |  `...` |  `?:` |  `not` | `=` | `and` | `or` |

### 9.6.1 二元运算符
定义四则运算符等二元运算符时，会将运算符名作为方法名，按照定义方法的做法重定义运算符。运算符的左侧为接收者，右侧作为方法的参数被传递：
```ruby
class Point
  attr_accessor :x, :y
  def initialize(x=0, y=0)
    @x, @y = x, y
  end
  def inspect        # 用p 方法显示（x,y）
    "(#{x}, #{y})"
  end
  def +(other)       # x、y 分别进行加法运算
    self.class.new(x + other.x, y + other.y)
  end
  def -(other)       # x、y 分别进行减法运算
    self.class.new(x - other.x, y - other.y)
  end
end

point0 = Point.new(3, 6)
point1 = Point.new(1, 8)
p point0             #=> (3, 6)
p point1             #=> (1, 8)
p point0 + point1    #=> (4, 14)
p point0 - point1    #=> (2, -2)
```
如上所示，定义二元运算符时，通常把参数名定义为 other。

在定义运算符 + 和 - 的程序中，创建新的 Point 对象时，我们使用了 self.class.new 。
而像下面这样，直接使用 Point.new 方法也能达到同样的效果。
```ruby
def +(other)
  Point.new(x + other.x, y + other.y)
end
```
使用上面的写法时，返回值一定是 Point 对象。如果 Point 类的子类使用了 + 和 - ，则返回的对象应该属于 Point 类的子类，但是这样的写法却只能返回 Point 类的对象。在方法内创建当前类的对象时，不直接写类名，而是使用 self.class， 那么创建的类就是实际调用 new 方法时的类，这样就可以灵活地处理继承与Mix-in 了。

### 专栏：puts 方法与 p 方法的不同点
上面的代码定义了用于显示的 inspect 方法，在 p 方法中把对象转换为字符串时会用到该方法。另外，使用 to_s 方法也可以把对象转换为字符串，在 puts、 print 方法中都有使用 to_s 方法。下面我们来看看两者的区别。
```
> irb --simple-prompt
>> str = "Ruby 基础教程"
=> "Ruby 基础教程"
>> str.to_s
=> "Ruby 基础教程"
>> str.inspect
=> "\"Ruby 基础教程\""
```

String#to_s 的返回结果与原字符串相同，但 String#inspect 的返回结果中却包含了 \" 。这是因为 p 方法在输出字符串时，为了让我们更明确地知道输出的结果就是字符串而进行了相应的处理。这两个方法的区别在于，作为程序运行结果输出时用 to_s 方法，给程序员确认程序状态、调查对象内部信息等时用 inspect 方法。

除了 puts 方法、 print 方法外， to_s 方法还被广泛应用在 Array#join 方法等内部需要进行字符串处理的方法中。

inspect 方法可以说是主要使用 p 方法进行输出的方法。例如，irb 命令的各行结果的显示就用到了 inspect 方法。我们在写程序时，如果能根据实际情况选择适当的方法，就会达到事半功倍的效果。

### 9.6.2 一元运算符
可定义的一元运算符有 + 、 - 、 ~ 、 ! 四个。它们分别以+@、－@、~@、!@ 为方法名进行方法的定义。下面就让我们试试在 Point 类中定义这几个运算符。（这里需要注意的是，一元运算符都是没有参数的。）
```ruby
class Point
  …
  def +@
    dup                     # 返回自己的副本
  end
  def -@
    self.class.new(-x, -y)  # 颠倒x、y 各自的正负
  end
  def ~@
    self.class.new(-y, x)   # 使坐标翻转90 度
  end
end

point = Point.new(3, 6)
p +point #=> (3, 6)
p -point #=> (-3, -6)
p ~point #=> (-6, 3)
```

### 9.6.3 下标方法
数组、散列中的 obj[i] 以及obj[i] =x 这样的方法，称为**下标方法**。定义下标方法时的方法名分别为 [] 和 []= 。下面的代码定义了 Point 类的实例 point 的下标方法，实现以 point[0] 的形式访问 point.x， 以 point[1] 的形式访问 point.y：

```ruby
class Point
  …
  def [](index)
    case index
    when 0
      x
    when 1
      y
    else
      raise ArgumentError, "out of range `#{index}'"
    end
  end

  def []=(index, val)
    case index
    when 0
      self.x = val
    when 1
      self.y = val
    else
      raise ArgumentError, "out of range `#{index}'"
    end
  end
end

point = Point.new(3, 6)
p point[0]     #=> 3
p point[1] = 2 #=> 2
p point[1]     #=> 2
p point[2]     #=> 错误（ArgumentError）
```
