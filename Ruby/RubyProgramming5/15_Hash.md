# 第15章 散列类
---

[TOC]

## 15.1 复习散列
在复习散列前，我们再次回顾一下数组的用法。通过索引可以获取数组元素或对其赋值：
```ruby
person = Array.new
person[0] = " 田中一郎"
```

散列与数组一样，都是表示对象集合的对象。数组通过索引访问对象内的元素，而散列则是使用键。索引只能是数值，而键则可以是任意对象。通过使用键，散列就可以实现对元素的访问
与赋值。

## 15.2 散列的创建
与数组一样，创建散列的方法也有很多，其中下面两种是最常用到的。

### 15.2.1 使用{}
使用字面量直接创建散列。
```ruby
{ 键 => 值}
```

像下面这样指定键值对，键值对之间用逗号（,）隔开。
```ruby
h1 = {"a"=>"b", "c"=>"d"}
p h1["a"] #=> "b"
```

另外，用符号作为键时，也可以采用下述定义方法。
```ruby
{ 键: 值}
```

```ruby
h2 = {a: "b", c: "d"}
p h2 #=> {:a=>"b", :c=>"d"}
```

### 15.2.2 使用 Hash.new
Hash.new 是用来创建新的散列的方法。若指定参数，则该参数值为散列的默认值，也就是
指定不存在的键时所返回的值。未指定参数时，散列的默认值为nil。

散列的键可以使用各种对象，不过一般建议使用下面的对象作为散列的键。
- 字符串（String）
- 数值（Numeric）
- 符号（Symbol）
- 日期（Date）

## 15.3 值的获取与设定
与数组一样，散列也用 [] 来获取或设定与键相对应的值。
```ruby
h = Hash.new
h["R"] = "Ruby"
p h["R"] #=> "Ruby"
```

另外，还可以用 store 方法设定值，用 fetch 方法获取值。下面的例子的执行结果与上面的例子是一样的。
```ruby
h = Hash.new
h.store("R", "Ruby")
p h.fetch("R") #=> "Ruby"
```

使用 fetch 方法时，有一点与 [] 不一样，就是如果散列中不存在指定的键，程序就会发生异常。
```ruby
h = Hash.new
p h.fetch("N") #=> 错误（KeyError）
```

如果对 fetch 方法指定第2 个参数，那么该参数值就会作为键不存在时的返回值。
```ruby
h = Hash.new
h.store("R", "Ruby")
p h.fetch("R", "(undef)") #=> "Ruby"
p h.fetch("N", "(undef)") #=> "(undef)"
```

此外， fetch 方法还可以使用块，此时块的执行结果为键不存在时的返回值。
```ruby
h = Hash.new
p h.fetch("N"){ String.new } #=> ""
```

### 15.3.1 一次性获取所有的键、值
我们可以一次性获取散列的键、值。由于散列是键值对形式的数据类型，因此获取键、值的方法是分开的。此外，我们还可以选择是逐个获取，还是以数组的形式一次性获取，不过这两种情况下使用的方法是不同的。

| 获取散列的键与值的方法 | 数组形式 | 迭代器形式 |
| -- | -- | -- |
| 获取键 | keys | each_key{ \| 键 \| ......} |
| 获取值 | values | each_value{ \| 值\| ......} |
| 获取键值对 [ 键, 值] | to_a | each{ \| 键 , 值 \| ......}, each{ \| 数组 \| ......} |

keys 与 values 方法各返回封装为数组后的散列的键与值。t o_a 方法则会先按 `[ 键, 值 ]` 的形式把键值对封装为数组，然后再将所有这些键值对数组封装为一个大数组返回。

### 15.3.2 散列的默认值
在获取散列值时，即使指定了不存在的键，程序也不会发生错误，而是会返回某个值。我们有 3 种方法来指定这种情况下的返回值。

- **创建散列时指定默认值**
  Hash.new 的参数值即为散列的默认值（什么都不指定时默认值为 nil），所有的键都共享这个默认值。
  ```ruby
  h = Hash.new(1)
  h["a"] = 10
  
  p h["a"] #=> 10
  p h["x"] #=> 1
  p h["y"] #=> 1
  ```
- **指定生成散列默认值的块**
  当希望不同的键返回不同的值时，或者不希望所有的键共享一个值时，可以在Hash.new方法中指定块。
  ```ruby
  h = Hash.new do |hash, key|
  hash[key] = key.upcase
  end
  h["a"] = "b"
  p h["a"] #=> "b"
  p h["x"] #=> "X"
  p h["y"] #=> "Y"
  ```
- **用fetch 方法指定**
  最后就是刚才已经介绍过的 fetch 方法。在 Hash.new 方法中指定了默认值或块时，会优先返回 fetch 方法的第2 个参数指定的值。
  ```ruby
  h = Hash.new do |hash, key|
  hash[key] = key.upcase
  end
  p h.fetch("x", "(undef)") #=> "(undef)"
  ```


## 15.4 查看指定对象是否为散列的键或值
- `h.key?(key)`, `h.has_key?(key)`, `h.include?(key)`, `h.member?(key)`：4 个方法都是查看指定对象是否为散列的键的方法，它们的用法和效果都是一样的。大家可以统一只用某一个，也可以根据不同的情况区分使用。散列h 中包含键 key 时返回 true ，否则返回 false 。
- `h.value?(value)`, `h.has_value?(value)`：查看散列的值中是否存在指定对象的方法。这两个方法只是把 key? 、 has_key? 方法中代表键的 key 部分换成了值value，用法是完全一样的。散列 h 中包含值value 时返回 true ，否则返回 false 。

## 15.5 查看散列的大小
- `h.size`, `h.length`：我们可以用 length 方法或者 size 方法来查看散列的大小，也就是键的数量。
- `h.empty?`：我们可以用 empty? 方法来查看散列的大小是否为0，也就是散列中是否不存在任何键。

## 15.6 删除键值
和数组一样，我们也可以成对地删除散列中的键和值。
- `h.delete(key)`：删除指定的键可以用 delete 方法。delete 方法也能在参数中指定块。指定块后，如果不存在键，则返回块的执行结果。
- `h.delete_if{|key, val| … }`, `h.reject!{|key, val| … }`：希望只删除符合某种条件的键值时，可以使用 delete_if 方法。另外，虽然reject! 方法的用法与delete_if 方法相同，但当不符合删除条件时，delete_if 方法返回的是原来的散列，而reject! 方法返回的则是 nil。

## 15.7 初始化散列
- `h.clear`：可以用 clear 方法清空使用过的散列。
  这有点类似于使用下面的方法创建新的散列并赋值。
  ```ruby
  h = Hash.new
  ```
  实际上，如果程序中只有一个地方引用 h 的话，两者的效果是一样的。不过如果还有其他地方引用 h 的话，那效果就不一样了。我们来对比一下下面两个例子
  ```ruby
  # 【例1】
  h = {"k1"=>"v1"}
  g = h
  h.clear
  p g #=> {}
  ```
  ```ruby
  # 【例2】
  h = {"k1"=>"v1"}
  g = h
  h = Hash.new
  p g #=> {"k1"=>"v1"}
  ```

  

  在例1 中， h.clear 清空了 h 引用的散列，因此 g 引用的散列也被清空， g 与 h 还是引用同一个散列对象；  而在例2 中，程序给 h 赋值了新的对象，但 g 还是引用原来的散列，也就是说， g 与 h 分别引用不同的散列对象。**需要注意的是，这里方法操作的不是变量，而是变量引用的对象。**

**处理有两个键的散列**
散列的值也可以是散列，也就是所谓的“散列的散列”，这与数组中的“数组的数组”的用法是一样的。

## 15.8 合并两个散列
使用Hash#merge 方法可以合并两个散列，创建一个新的散列。
```ruby
p ({"a"=>"x"}.merge({"b"=>"y"})) #=> {"a"=>"x", "b"=>"y"}
```

Hash#merge! 是Hash#merge 对应的具有破坏性的方法，它会更新作为接收者的散列。Hash#merge! 还有一个别名叫Hash#update，两者的用法相同。

## 15.9 应用示例：计算单词数量
下面我们用散列写个简单的小程序。如下代码中，程序会统计指定文件中的单词数量，并按出现次数由多到少的顺序将其显示出来。
```ruby
# 计算单词数量
count = Hash.new(0)

## 统计单词
File.open(ARGV[0]) do |f|
  f.each_line do |line|
    words = line.split
    words.each do |word|
      count[word] += 1
    end
  end
end

## 输出结果
count.sort{|a, b|
  a[1] <=> b[1]
}.each do |key, value|
  print "#{key}: #{value}\n"
end
```

### 专栏：关于散列的值
下面我们来讨论一下用数值或者自己定义的类等对象作为散列的键时需要注意的地方。

我们首先尝试创建一个以数值为键的散列：
```ruby
h = Hash.new
n1 = 1
n2 = 1.0
p n1= =n2           #=> true
h[n1] = "exists."
p h[n1]             #=> "exists."
p h[n2]             #=> nil
```

用 n1 可以获取以 n1 为键保存的值，但是用与 n1 有相同值的 n2 却无法获取。这是由于使用 n2 时，无法在散列中找到与之对应的键，因此就返回了默认值 nil。

在散列内部，程序会将散列获取值时指定的键，与将值保存到散列时指定的键进行比较，判断两者是否一致。这时，判断键是否一致与键本身有着莫大的关系。具体来说，对于两个键 k ey1、 k ey2， 当 key1.hash 与 key2.hash 返回相同的主值，且 key1.eql?(key2) 为 true 时，就会认为这两个键是一致的。像本例那样，虽然使用 == 比较时得到的结果是一致的，但是，当两个键分别属于 Fixnum 类和 Float 类的对象时，由于不同类的对象不能判断为相同的键，因此就会产生与期待不同的结果。