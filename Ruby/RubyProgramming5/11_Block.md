第11章 块
---

[TOC]

Ruby 中大量使用了块（有时也称代码块。——译者注）。块原本只是为了循环而产生的语法结构，但现在程序中很多地方也都使用了块。因此，如何灵活地使用块，也是Ruby 的重点之一。

## 11.1 块是什么
**块**（block）就是在调用方法时能与参数一起传递的多个处理的集合。之前在介绍 each 方法、time 方法等与循环有关的部分时，我们就已经接触过块。接收块的方法会执行必要次数的块。块的执行次数由方法本身决定，因此无需事前指定，甚至有可能一次都不执行。

带块的方法调用一般采用以下形式。
```ruby
对象. 方法名( 参数列表) do | 块变量|
  希望循环的处理
end
```
或者
```ruby
对象. 方法名( 参数列表) { | 块变量|
  希望循环的处理
}
```

块的开头是**块变量**。块变量就是在执行块时，从方法传进来的参数。不同方法的块变量个数也不相同。也有像第6 章介绍的loop 方法那样没有块变量的方法。

## 11.2 块的使用方法

### 11.2.1 循环
在Ruby 中，我们常常使用块来实现循环。在接收块的方法中，实现了循环处理的方法称为**迭代器**（iterator）。 each 方法就是一个典型的迭代器。

下面是一些例子：
1. 数组：在下面的例子中，我们把数组的各个元素转换为大写后输出。
    ```ruby
    alphabet = ["a", "b", "c", "d", "e"]
    alphabet.each do |i|
        puts i.upcase
    end
    ```
2. 散列：和数组一样，散列也能将元素逐个取出来，但不同的是，散列会将 [ 键, 值] 的组合作为数组来提取元素。本例中使用 pair[1] 提取并合计了散列的值，提取散列的键时则可以使用p air[0]。
    ```ruby
    sum = 0
    outcome = {" 参加费"=>1000, " 挂件费用"=>1000, " 联欢会费用  "=>4000}
    outcome.each do |pair|
      sum += pair[1] # 指定值
    end
    puts " 合计：#{sum}"
    ```

    在接收块变量时，多重赋值规则也是同样适用的。我们把上面的程序稍微修改一下，这样键、值就可以被分别赋值给不同的变量了。
    ```ruby
    sum = 0
    outcome = {" 参加费"=>1000, " 挂件费用"=>1000, " 联欢会费用"=>4000}
    outcome.each do |item, price|
      sum += price
    end
    puts " 合计：#{sum}"
    ```

3. 其他：如下是一个使用了File 类的 each 方法的程序示例，它会把sample.txt 文件的内容按顺序逐行读取出来并输出。
    ```ruby
    file = File.open("sample.txt")
    file.each_line do |line|
      print line
    end
    file.close
    ```
    除了逐行循环读取数据的 each_line 方法外，File 对象中还有以字符为单位来循环读取数据的 each_char 方法，以及以字节为单位进行循环读取的each_byte 方法等。而其他对象也有很多以 each_×× 命名的循环读取数据的方法。

### 11.2.2 隐藏常规处理
除了迭代器以外，块还被广泛使用在其他地方。其中一个用法就是确保后处理被执行。一个典型的例子是 File.open 方法。 File.open 方法在接收块后，会将File 对象作为块变量，并执行一次块。
```ruby
File.open("sample.txt") do |file|
  file.each_line do |line|
    print line
  end
end
```

与改写之前的程序相比，File 对象读取数据的部分一样，不同点在于没有了最后的close方法的调用。如果使用完打开的文件后没有将文件关闭，就可能会产生其他程序无法打开该文件，或者到达一次性可打开的文件数的上限时无法再打开新文件等问题。而在上面的程序中，即使遇到无法打开文件等错误也可以正常关闭文件，因为块内部进行了如下的处理。
```ruby
file = File.open("sample.txt")
begin
  file.each_line do |line|
    print line
  end
ensure
  file.close
end
```

在 File.open 方法中使用块时，在块内部的处理完毕并跳出方法前，文件会被自动关闭，因此就不需要使用 File#close 方法。文件使用完毕后，由方法执行关闭操作，而我们只需将必要的处理记述在块中即可。这样既可以减少程序的代码量，也可以防止忘记关闭文件等错误的发生。

### 11.2.3 替换部分算法
下面我们再来介绍一个块的常见用法。这一次我们以数组排序为例，来了解一下指定处理顺序时块的使用方法。

**自定义排列顺序**
Array 类的 sort 方法是对数组元素进行排序的方法。对数组元素进行排序，可以采取多种方法。
> **备注**：将数组等中的元素按照一定的顺序重新排列的过程，我们称为“排序”。

- 按数字的大小顺序
- 按字母顺序
- 按字符串的长度顺序
- 按数组元素的合计值的大小顺序

如果按照这样的条件分别定义相应的排序方法，就会使方法的数量过多，不便于记忆。因此，在 Array#sort 方法中，元素的排序步骤由方法决定，用户只能指定元素间前后关系的比较逻辑。

Array#sort 方法没有指定块时，会使用 <=> 运算符对各个元素进行比较，并根据比较后的结果进行排序。 <=> 运算符的返回值为－1、0、1 中的一个。

| 情况 | 返回值 |
| -- | -- |
| a < b 时 | -1（比0 小）|
| a = = b 时 | 0 |
| a > b 时 | 1（比 0 大） |

使用 <=> 运算符比较字符串时，会按照字符编码的值的大小进行比较。比较字母时，会按先大写字母后小写字母的顺序排列。
```ruby
array = ["Ruby", "Perl", "PHP", "Python"]
sorted = array.sort
p sorted #=> ["PHP", "Perl", "Python", "Ruby"]
```

我们可以通过调用块来指定排列顺序。下面的例子与不使用块时的执行结果是一样的。
```ruby
array = ["Ruby", "Perl", "PHP", "Python"]
sorted = array.sort{ |a, b| a <=> b }
p sorted #=> ["PHP", "Perl", "Python", "Ruby"]
```

在 sort 方法的末尾添加了块 { |a, b| a <=> b } ，sort 方法会根据块的执行结果判断元素的大小关系。当需要比较元素的大小关系时，块中需要比较的两个对象就会被作为块变量调用。对块变量 a 和 b 进行比较后，数组整体就会按该顺序排列。在这里，我们需要注意块中最后一个表达式的值就是块的执行结果，因此 <=> 运算符必须在最后一行使用。

> **备注**：块的最后一个表达式不是指块的最后一行表达式，而是指在块中最后执行的表达式。

我们可以使用块指定不同的排序顺序。像这样，块经常被用来在 sort 方法中实现自定义排列顺序。

**预先取出排序所需的信息**
我们再来详细看看 sort 方法的块。每次比较元素时， sort 方法都会调用一次将两个元素作为块变量的块。这里，我们仍以刚才介绍的按字符串长度排序的程序为例，来看看程序调用了 length 方法多少次。
```ruby
#%w(...) 是一个用于生成以各单词为元素的数组的字面量
ary = %w(
  Ruby is a open source programming language with a focus
  on simplicity and productivity. It has an elegant syntax
  that is natural to read and easy to write
)
call_num = 0 # 块的调用次数
sorted = ary.sort do |a, b|
  call_num += 1 # 累加块的调用次数
  a.length <=> b.length
end

puts " 排序结果 #{sorted}"
puts " 数组的元素数量 #{ary.length}"
puts " 调用块的次数 #{call_num}"
```

示例结果：
```
排序结果 ["a", "a", "on", "to", "It", "to", "is", "an", ...]
数组的元素数量 28
调用块的次数 91
```

可以看出，在这个例子中对28 个元素进行了排序，块总共被调用了91 次。由于每调用1次块， length 方法就会被调用2 次，因此最终就会被调用182 次。而实际上，我们只需对所有的字符串都调用1 次 length 方法，然后再用得出的结果进行排序就可以了。像这样，在能够通过 <=> 运算符对转换后的结果进行比较的情况下，使用 sort_by 方法会使排序更加有效率。
```ruby
ary = %w(
  Ruby is a open source programming language with a focus
  on simplicity and productivity. It has an elegant syntax
  that is natural to read and easy to write
)
sorted = ary.sort_by{ |item| item.length }
p sorted
```

sort_by 方法会将每个元素在块中各调用一次，然后再根据这些结果进行排序处理。这种情况下，虽然调用<=> 运算符的次数不变，但获取排序所需要的信息的次数（本例中为28 次）只需与元素个数一样就可以了。

总结一下，**元素排序算法中共通的部分由方法本身提供，我们则可以用块来替换方法中元素排列的顺序（或者获取用于比较的信息），或者根据不同的目的来替换需要更改的部分。**

## 11.3 定义带块的方法

### 11.3.1 执行块
在第7章我们使用过如下的 `myloop` 方法：
```ruby
def myloop
  while true
    yield # 执行块
  end
end
num = 1 # 初始化num
myloop do
  puts "num is #{num}" # 输出num
  break if num > 100 # num 超过100 后跳出循环
  num *= 2 # num 乘2
end
```
myloop 方法在执行 while 循环的同时执行了 yield 关键字， yield 关键字的作用就是执行方法的块。因为这个 while 循环的条件固定为 true ，所以会无限循环地执行下去，但只要在块中调用 break， 就可以随时中断 myloop 方法，来执行后面的处理。

### 11.3.2 传递块参数，获取块的值
接下来，我们定义一个方法，该方法接收两个整数参数，并依次提取第一个整数与第二个整数之间的整数值，对这些值分别进行某种处理后再进行合计处理，而“某种处理”则由块指定
```ruby
def total(from, to)
  result = 0 # 合计值
  from.upto(to) do |num| # 处理从from 到to 的值
    if block_given? # 如果有块的话
      result += yield(num) # 累加经过块处理的值
    else # 如果没有块的话
      result += num # 直接累加
    end
  end
  return result # 返回方法的结果
 end
p total(1, 10) # 从1 到10 的和 => 55
p total(1, 10){|num| num ** 2 } # 从1 到10 的2 次幂的和 => 385
```

total 方法会先使用 Integer#upto 方法把 from 到 to 之间的整数值按照从小到大的顺序取出来，然后交给块处理，最后再将块处理后的值累加到变量 result 中。程序第5 行中，对 yield 传递参数后，参数值就会作为块变量传递到块中。同时，块的运行结果也会作为 yield 的结果返回。
程序第4 行的 `block_given?` 方法被用来判断调用该方法时是否有块被传递给方法，如果有则返回 true， 反之则返回 false。 如果方法没有块，则在程序第7行中直接把 num 相加。

在实际程序中，如果 yield 参数的个数与块变量的个数不一样，则块变量比较多时，多出来的块变量值为 nil ；块变量不足时，则不能接收参数值。另外还可以通过 |*a| 将所有块变量整合为一个数组来接收。这与定义方法时接收可变参数的情况非常相似。

### 11.3.3 控制块的执行
下面我们来看一下 break 等方法是如何控制块的执行的。
- 如果在块中使用 `break`， 程序会马上返回到调用块的地方，因此返回计算结果的处理等都会被忽略掉。但作为方法的结果，当我们希望返回某个值时，就可以像 break 0 这样指定 break 方法的参数，这样该值就会成为方法的返回值。
-  如果在块中使用 `next`， 程序就会中断当前处理，并继续执行下面的处理。使用 next 后，执行块的 yield 会返回，如果 next 没有指定任何参数则返回 nil ，而如果像 next 0 这样指定了参数，那么该参数值就是返回值。
- 如果在块中使用了 `redo` ，程序就会返回到块的开头，并以相同的块变量再次执行处理。这种情况下，块的处理结果不会返回给外部，因此需要十分小心 redo 的用法，注意不要使程序陷入死循环。

### 11.3.4 将块封装为对象
Ruby 还能把块当作对象处理。把块当作对象处理后，就可以在接收块的方法之外的其他地方执行块，或者把块交给其他方法执行。把块当作对象操作时，我们需要用到 Proc 对象。定义 Proc 对象的典型的方法是，调用 Proc.new 方法这个带块的方法。在调用 Proc 对象的 call 方法之前，块中定义的程序不会被执行。

在下面的例子中，定义一个输出信息的 Proc 对象，并调用两次。这时，程序就会把 call 方法的参数作为块参数来执行块。
```ruby
hello = Proc.new do |name|
  puts "Hello, #{name}."
end
hello.call("World")
hello.call("Ruby")
```

把块从一个方法传给另一个方法时，首先会通过变量将块作为 Proc 对象接收，然后再传给另一个方法。在方法定义时，如果末尾的参数使用 `&参数名` 的形式，Ruby 就会自动把调用方法时传进来的块封装为 Proc 对象。

```ruby
def total2(from, to, &block)
  result = 0                       # 合计值
  from.upto(to) do |num|           # 处理从from 到to 的值
    if block                       # 如果有块的话
      result +=                    # 累加经过块处理的值
      block.call(num)
    else                           # 如果没有块的话
      result += num                # 直接累加
    end
  end
  return result                    # 返回方法的结果
end
p total2(1, 10)                    # 从1 到10 的和 => 55
p total2(1, 10){|num| num ** 2 }   # 从1 到10 的2 次幂的和 => 385
```

在首行的方法定义中定义了 &block 参数。像这样，在变量名前添加 & 的参数称为 Proc 参数。如果在调用方法时没有传递块， Proc 参数的值就为 nil ，因此通过这个值就可以判断出是否有块被传入方法中。另外，执行块的语句不是 yield， 而是 block.call(num)， 这一点与之前的例子也不一样。

将块封装为 Proc 对象后，我们就可以根据需要随时调用块，甚至还可以将其赋值给实例变量，让别的实例方法去任意调用。
此外，我们也能将 Proc 对象作为块传给其他方法处理。这种情况下，只需在调用方法时，用“&Proc 对象”的形式定义参数就可以了。

```ruby
def call_each(ary, &block)
  ary.each(&block)
end

call_each [1, 2, 3] do |item|
  p item
end
```
这样一来，我们就可以非常方便地把调用 call_each 方法时接收的块，原封不动地传给 ary.each 方法。

## 11.4 局部变量与块变量
块内部的命名空间与块外部是共享的。在块外部定义的局部变量，在块中也可以继续使用。而被作为块变量使用的变量，即使与块外部的变量同名，Ruby 也会认为它们是两个不同的变量。相反，在块内部定义的变量不能被外部访问。

块中变量的作用域之所以这么设计，是为了通过与块外部共享局部变量，从而扩展变量的有效范围。在块内部给局部变量赋值时，要时刻注意它与块外部的同名变量的关系。大家一定要小心Ruby 中的这个小陷阱。块变量是只能在块内部使用的变量（块局部变量），不能覆盖外部的局部变量，但Ruby 为我们提供了定义块变量以外的块局部变量的语法，即通过在块变量后加上 ; 来定义。

### 专栏：关于Ruby 的帮助文档
由于篇幅有限，书中只能介绍Ruby 的要点，未能囊括Ruby 所有的功能。对于本书未涉及的内容，有兴趣的读者可以查阅Ruby 的帮助文档。
- **Web 上的资源**
  Ruby 的帮助文档是用英文写的。另外，Ruby 社区维护的Ruby Documentation Project 提供了一个支持快速精准查找的Ruby 文档系统。以下是Ruby 文档的URL。
  - 帮助文档（Ruby官方网站）
    [https://www.ruby-lang.org/zh_cn/documentation/（简体中文）](https://www.ruby-lang.org/zh_cn/documentation/（简体中文）)
    [https://www.ruby-lang.org/en/documentation/（英文）](https://www.ruby-lang.org/en/documentation/)
  - Ruby Documentation Project
    [http://ruby-doc.com/](http://ruby-doc.com/)
- **阅读帮助文档的技巧**
  下面我们列举4 个阅读帮助文档的技巧。
  - **查阅类或方法时，从Ruby的“核心库”和“标准库”开始查找**
    核心库的URL 是http://ruby-doc.org/core-2.3.0/，标准库的URL 是http://ruby-doc.org/stdlib-2.3.0/。大家可以试试从这两个地方开始查找想了解的对象的类。
  - **使用“搜索”查找方法**
    由于帮助文档只是罗列了类和模块，肉眼去寻找方法非常困难，因此与其费劲地从头慢慢找，不如充分利用帮助文档的搜索功能，这样能更快地找到想要的结果。（帮助文档搜索页面：http://ruby-doc.com/search.html）
  - **也要查找父类的方法**
    有时看完当前类的文档依然找不到我们想要找的方法。这种情况下，很可能我们要查找的方法定义在了父类而不是当前类。也就是说，当前类使用了从父类继承的方法。
  - **不要死记硬背**
    Ruby 核心的标准方法相当多，再加上标准库的方法，要完全掌握所有方法是不可能的。因此，我们只需要抱着“仅在需要时阅读需要的部分”的态度，慢慢地熟悉Ruby 即可。当熟悉了Ruby 以后，建议再通读某个类的所有方法或通读语法说明。
