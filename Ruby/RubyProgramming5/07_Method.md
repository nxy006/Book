# 第07章 方法
---

**方法**是由对象定义的与该对象相关的操作，在 Ruby 中，对象的所有操作都被封装为方法。

[TOC]

## 7.1 方法的调用

### 7.1.1 简单的方法调用
调用方法的语法如下所示：
```ruby
对象.方法名 (参数1, 参数2, ..., 参数n)
```

上面的对象被称为**接收者**（receiver）。在面向对象的世界中，调用方法被称为“向对象发送消息（message）”，调用的结果就是“对象接收（receive）了消息”。也就是说，方法的调用就是把几个参数连同消息发送给对象的过程。

### 7.1.2 带块的方法调用
正如第6章提到的each、loop 方法那样，方法本身可以与块一起调用，这被称为**带块的方法调用**。
```ruby
对象.方法名 (参数, ...) do | 变量1, 变量2, ... |
  块内容
end
```

`do ~ end` 这部分就是所谓的块。除 `do ~ end` 这一形式，我么也可以用 `{ ~ }` 将块改写为其他形式。
```ruby
对象.方法名 (参数, ...) { | 变量1, 变量2, ... |
  块内容
}
```

> 注：使用 do ~ end 时，可以省略扩起参数列表的 ()；使用 `{ ~ }` 则只能在没有参数的时候省略，有一个以上的参数时就不能省略。

在块开头的 `| ~ |` 部分中指定的变量称为**块变量**。在执行块的时候，块变量由方法传到块内部。不同的块方法对应的块变量的个数和值也不一样。

### 7.1.3 运算符形式的方法调用
Ruby 中有些方法很像运算符，例如四则运算符等二元运算符、-（负号）等一元运算符，指定元素下标的 `[]` 等实际上都是方法。
- `obj + arg1`
- `obj =~ arg1`
- `-obj`
- `!obj`
- `obj[arg1]`
- `obj[arg1] = arg2`

这些方法虽然与一般的方法调用语法不同，但我们可以将 obj 理解为接收者，arg1，arg2 理解为参数，这样就是我们熟知的方法了。
> 注：运算符中，有些可以自由地重新定义，有些则不能，关于运算符详见第 9 章

## 7.2 方法的分类
根据接收者种类的不同，Ruby 方法可分为以下三类：
- 实例方法
- 类方法
- 函数式方法

### 7.2.1 实例方法
实例方法是最常用的方法，以对象（示例）为接收者的方法称为**实例方法**。

对象能调用的实例方法是由对象所属的类决定的，调用后程序会执行对象所属的类预先定义好的处理。虽然相同名称的方法执行的处理大多一样，但具体执行的内容则根据对象类型不同而存在区别。

### 7.2.2 类方法
接收者不是实例而是类本身的方法，称为**类方法**。
例如，我们在创建对象时就使用类方法，对实例所属的类进行操作也会用到类方法，类方法也有运算符的形式。
```ruby
Array.new                        # 创建新的数组
File.open("some_file")           # 创建新的文件对象
File.rename(oldname, newname)    # 修改文件名
Array["a", "b", "c"]             # 创建 ["a", "b", "c"] 数组
```

### 7.2.3 函数式方法
没有接收者的方法，我们成为**函数式方法**。
虽说没有接收者，但并不代表该方法真的没有可作为接收者的对象，只是在函数式方法的情况下，可以省略而已。
```ruby
print "hello"  # 在命令行输出字符串
sleep(10)      # 在指定的时间内睡眠，终止程序
```

函数式方法的执行结果不会根据接收者的状态而变化。程序在执行 `print` 方法时并不需要知道接收者是谁。反过来说，不需要接收者的方法就是函数式方法。

### 专栏：方法的标记法
Ruby 帮助文档中方法名具有不同的标记方法，标记某个类的实例方法时，可以采用 `类名 # 类方法` 的标记方法。

注意这只是写文档时的标记方法，不能在程序中书写。另外，类方法还有下面两种写法：
- `类名 . 方法名`
- `类名 :: 方法名`


## 7.3 方法的定义
定义方法的一般语法如下所示：
```ruby
def 方法名 ( 参数1, 参数2, ...)
  希望执行的处理
end
```

方法名可以由英文字母、数字、下划线组成，但不能以数字开头。

> 虽然在说明定义实例方法或类方法之前，应该先说明如何定义类，但关于类的定义还未说明。因此，现在我们只需掌握：定义了方法之后，就能像省略接收者的函数式方法那样调用方法了。

也可以指定默认值给参数，定义方法时，用 `参数名=值` 这样的写法定义默认值。有多个参数时，可以从参数列表的右边开始依次指定默认值，以省略代码。注意只省略左边的参数或者中间某个参数是不行的。

### 7.3.1 方法的返回值
我们可以用 `return` 语句指定方法的返回值。
```ruby
return 值
```

`return` 语句可以省略，这时方法的最后一个表达式结果就会成为方法的返回值，返回值并不一定是最后一行的结果，比如在 `if ~ else ~ end` 语句作为结尾时中将返回所进入分支的值。

`return` 语句可以用于希望马上终止程序的情况。如果省略 `return` 的参数，程序将返回 `nil`。

### 7.3.2 定义带块的方法
我们首先来实现 `myloop` 方法，它与利用块实现循环的 `loop` 方法是一样的：
```ruby
def myloop
  while true
    yield
  end
end

# Test
num = 1
myloop do
  puts "num is #{num}"
  break if num > 10
  num *= 2
end
```

这里第一次出现了 `yield`关键字，`yield` 是定义带块的方法时最重要的关键字。定义方法时通过块传进来的处理会在 `yield` 定义的地方执行。

如果 yield 部分有参数，出现就会将其当做块变量传到块中。块中最后的表达式的值，既是块的执行结果，也可以作为 `yield` 的返回值在块的外部使用。

> **引用**：关于带块的方法的使用方法，我们将在 第11章 详细说明。

### 7.3.3 参数个数不确定的方法
通过使用 `* 变量名` 形式定义参数个数不确定的方法，就可以将参数封装为数组，供方法内部使用。这种形式的参数只能在方法参数列表中出现一次。

### 7.3.4 关键字参数
使用 **关键字参数**，可以将参数名与参数的值成对地传给方法使用，而不用按顺序和数量使用。
```ruby
def 方法名 ( 参数1: 参数1的值, 参数2: 参数2的值 , ...)
  希望执行的处理
end
```

使用 `参数名: 参数值` 的形式还可以指定参数的默认值，如果不需要定义默认值，只需要像 `参数名:` 这样指定即可，省略了默认值的参数在调用时不可以被省略。

如果传输给方法未定义的参数名，程序就会报错。为了避免因指定未定义的参数而报错，我们可以使用 `** 变量名` 的形式接收未定义的值，参数将把未定义的关键字参数以散列的形式保存。
```ruby
def meth(x: 0, y: 0, z: 0, **args)
  [x, y, z, args]
end

p meth(z: 4, y: 3, x: 2)      #=> [2, 3, 4, {}]
p meth(x: 2, z: 3, v: 4,w: 5) #=> [2, 0, 3, {:v=>4, :w=>5}] 
```

关键字参数可以与普通参数搭配使用；
也可以把散列作为关键字参数传给方法，但这时散列的值只能为符号。此时可以省略定义了默认值的关键字参数，但传递多余的键会导致程序发生错误。

### 7.3.5 关于方法调用的一些补充
下面补充说明一些调用方法时传递参数的方法；
- **把数组分解为参数**
  将参数传递给方法，我们可以以 `* 数组` 这样的形式指定参数，就可以将数组元素按次序（而非传递数组本身）传递给方法，但数组的元素必须要和方法定义的参数个数相同。
  ```ruby
  def foo(a, b, c)
    a + b + c
  end
  
  p foo(1, 2, 3)   #=> 6
  
  arg1 = [2, 3]
  p foo(1, *arg1)  #=> 6
  
  arg2 = [1, 2, 3]
  p foo(*arg2)     #=> 6
  ```

- **把散列作为参数传递**
  我们用 `{ ~ }` 这样的形式表示散列，将散列作为参数传递给方法时可以省略 `{ }`。当仅有一个散列参数，或最后一个参数为散列时可以采取这种写法。把符号作为键的散列与使用关键字参数形式相同。其实，关键字参数就是模仿这种将散列作为参数传递的写法而设计的。使用关键字参数定义方法，既可以对键进行限制，又可以定义参数的默认值，建议使用。
  ```ruby
  def bar(arg1, arg2)
    [arg1, arg2]
  end
  p bar(100, {"a"=>1, "b"=>2})  #=> [100, {"a"=>1, "b"=>2}]
  p bar(100, "a"=>1, "b"=>2)    #=> [100, {"a"=>1, "b"=>2}]
  p bar(100, a: 1, b: 2)        #=> [100, {:a=>1, :b=>2}]
  ```

### 专栏：如何书写简明易懂的程序
通过注意下面的三点，可以使程序更加漂亮：
- **换行符和 “;”**
  ruby 的语法特征之一就是可以使用换行符作为语句结束的标志，而除此之外还可以使用 `;`，这样一来一行程序可以书写多条语句。但过多使用 `;` 会让程序难以理解，把换行作为自然的语句间隔能够便于我们读写程序。适当的换行符是书写简明易懂的程序的第一步。
- **缩进（indent）**
  缩进是指在程序行的开头输入适当的空白来强调程序整体感的一种写法，在 Ruby 中，我们一般用两个空格表示一个缩进。使用缩进能够让程序对应关系变得清晰明了。我们常在条件分支、循环、块、方法、类等的定义时使用缩进。
  使用缩进时，需要注意;
  - 不要突然使用缩进
  - 确保缩进的整齐
- **空白**
  空白存在于程序的各个角落，使用空白我们需要注意确保空白长度整齐，保持良好的平衡感。特别是，如果在运算符前后使用的空白长度不一样，程序就可能出现莫名的错误。例如可能将 `a +b`理解为调用a方法，参数为+b（即误认为：`a(+b)`）。
- **良好的编码风格**
  养成良好的编码风格，首先应该参考他人代码并模仿。编写程序的技巧、良好的编码风格都需要大量的阅读他人代码。
