# 第17章 IO类

---

[TOC]

## 17.1 输入/ 输出的种类

### 17.1.1 标准输入/ 输出

程序在启动后会预先分配3 个 IO 对象。

- **标准输入**

  标准输入是用于接收数据的IO 对象。可以通过预定义常量STDIN 调用IO 对象，也可以用全局变量 \$stdin 引用IO 对象。不指定接收者的gets 方法等都会默认从 \$stdin 中获取数据。标准输入最初与控制台关联，接收从键盘输入的内容。

- **标准输出**

  标准输出是用于输出数据的IO 对象。可以通过预定义常量STDOUT 调用IO 对象，也可以用全局变量 \$stdout 引用IO 对象。不指定接收者的 puts、print、printf 等方法会默认将数据输出到 \$stdout。标准输出最初与控制台关联。

- **标准错误输出**

  标准错误输出是用于输出警告、错误的 IO 对象。可以通过预定义常量STDERR 调用IO对象，也可以用全局变量\$stderr 引用 IO 对象。用于显示警告信息的 warn 方法会将信息输出到 \$stderr。标准错误输出最初与控制台关联。

虽然标准输出与标准错误输出都是向控制台输出内容，但我们可以根据输出的内容区别使用，程序本身的输出内容使用标准输出，错误、警告或者单纯的消息通知则使用标准错误输出。

```ruby
3.times do |i|
  $stdout.puts "#{Random.rand}" # 标准输出
  $stderr.puts " 已经输出了 #{i+1} 次" # 标准错误输出
end
```

将输出内容重定向到文件时，标准输出的内容会被写入到文件，只有标准错误输出的内容被输出到屏幕中。

```
> ruby out.rb > log.txt
已经输出了 1 次
已经输出了 2 次
已经输出了 3 次
```

利用两者输出的目标不一样这个特性，我们可以一边把作为程序结果的必要数据保存到文件中，一边在控制台中显示程序的处理情况。通过区分使用标准输出与标准错误输出，可以很方便地分开获取正常信息与错误信息。

> **备注**：在执行程序时，在命令后加上“> 文件名”，就可以将程序执行时的输出结果保存到文件中。我们把这个控制台的功能称为“重定向”。

> **备注**：ruby 命令的错误信息也会被输出到标准错误输出。

通常标准输入、标准输出、标准错误输出都是与控制台关联的，但是将命令的输出重定向到文件，或者使用管道（|）将结果传递给其他程序时则与控制台没有关系。根据实际的使用情况，程序根据输入/ 输出状态所进行的处理也各异。 IO 对象是否与控制台关联，可以通过 tty? 方法判断。

> **备注**：TTY 是Teletype 的缩写。

如下是一个检查标准输入是否为屏幕的例子。

```ruby
if $stdin.tty?
  print "Stdin is a TTY.\n"
else
  print "Stdin is not a TTY.\n"
end
```

普通调用、将命令的输出结果传给管道，或者通过文件输入内容时，程序的结果会不一样：

```
> ruby tty.rb
Stdin is a TTY.

> echo | ruby tty.rb
Stdin is not a TTY.

> ruby tty.rb < data.txt
Stdin is not a TTY.

```

### 17.1.2 文件输入/ 输出

通过 IO 类的子类 File 类可以进行文件的输入/ 输出处理。 File 类中封装了文件创建、删除等与文件系统相关的操作，而一些基本的输入/ 输出处理则使用继承自 IO 类的方法。

- `io = File.open(file[, mode[, perm]][, opt])`, `io = open(file[, mode[, perm]][, opt])`：通过 File.open 方法或 open 方法打开文件并获取新的 IO 对象。

  模式（mode）会指定以何种目的打开文件（表17.1）。缺省模式为只读模式（ "r" ）。在Windows环境下，在各模式后加上 b ，通过 "rb" 、 "rb+" 等形式即可表示二进制模式（后述）。Windows 以外的平台会忽略b 模式，不过为了便于辨别目标文件的类型，建议操作二进制文件时还是使用b模式。像"rt" 这样，在各模式末尾加上t，会将读写时的换行符统一为\n。

  | 模式 | 意义 |
  | -- | -- |
  | "r" | 用只读模式打开文件 |
  | "r+" | 用读写模式打开文件 |
  | "w" | 用只写模式打开文件。文件不存在则创建新的文件；文件已存在则清空文件，即将文件大小设置为 0 |
  | "w+" | 读写模式，其余同 "w" |
  | "a" | 用追加模式打开文件。文件不存在则创建新的文件 |
  | "a+" | 用读取/ 追加模式打开文件。文件不存在则创建新的文件 |

  权限模式（perm）用于指定新创建的文件的访问权限。关于文件的访问权限请参考18.3 节。

  选项（opt）为散列对象，用于指定其他选项，如下表所示。

  | 选项 | 意义 |
  | -- | -- |
  | :mode | 与参数mode 等价 |
  | :external_encoding | 指定外部编码。有关编码请参考第19 章 |
  | :internal_encoding | 指定内部编码 |
  | :encoding | 指定内部以及外部编码 |
  | :textmode | true 时，等价于将模式指定为t |
  | :binmode | true 时，等价于将模式指定为b |
  | :autoclose | false 时，则File 对象被GC 时不会关闭文件描述符（File Descriptor） |

- `file.close`：使用 close 方法关闭已打开的文件。

  一个程序中同时打开的文件数量是有限制的，因此使用完的文件应该尽快关闭。如果打开多个文件而不进行关闭操作，程序就很可能会在使用 open 方法时突然产生异常。File.open 方法如果使用块，则文件会在使用完毕后自动关闭。这种情况下， File 对象会被作为块变量传递给块。块执行完毕后，块变量引用的 File 对象也会自动关闭。这种写法会使输入/ 输出的操作范围更加清晰。

  ```ruby
  File.open("foo.txt") do |file|
    while line = file.gets
      …
    end
  end
  ```

- `file.closed?`：用 closed? 方法可以检查 File 对象是否关闭了。

- `File.read(file[, length [, offset ]]))`：不创建File 对象，直接读取file 里面的数据。参数length 指定读取的长度，offset 指定从前面第几个字节开始读取数据。若忽略这些参数，程序会从头到尾一次性读取文件内容。

- `File.binread(file[, length[, offset ]])`：以二进制模式打开并读取file。在读取二进制数据时可以用这个方法。

- `File.write(file[, data[, offset ]])`：不创建File 对象，直接向file 写入data。省略参数offset 时，会将文件的内容全部替换为data，指定了该参数时，则会将前面offset 个字节写入文件，后面的数据则保持不变。

- `File.binwrite(file[, data[, offset ]])`：以二进制模式打开并写入file。

## 17.2 基本的输入/ 输出操作

输入/ 输出操作的对象数据为字符串，也就是所谓的 String 对象。执行输入操作后，会从头到尾按顺序读取数据，执行输出操作后，则会按写入顺序不断追加数据。

### 17.2.1 输入操作

- `io.gets(rs)`, `io.each(rs)`, `io.each_line(rs)`, `io.readlines(rs)`：从 IO 类的对象io 中读取一行数据，用参数rs 中指定的字符串分行，省略 rs 时则使用预定义变量$ /（ 默认值为" \n"） 。

  这些方法返回的字符串中包含行末尾的换行符。用 chmop! 方法可以很方便地删除字符串末尾的换行符。

  输入完毕后再尝试获取数据时， gets 方法会返回 nil 。另外，可以使用 eof? 方法检查是否已经输入完毕。

  ```ruby
  while line = io.gets
    line.chomp!
    …  # 对line 进行的操作
  end

  p io.eof? #=> true
  ```

  while 条件表达式中同时进行了变量赋值与条件判断的操作。将 gets 方法的返回值赋值给 line， 并将该值作为 while 语句的条件来判断。上面是g ets 方法的经典用法，大家应该尽快掌握这种写法。用 each_line 方法也可以实现同样的效果。

  ```ruby
  io.each_line do |line|
    line.chomp!
    …  # 对line 进行的操作
  end
  ```

  另外，用 readlines 方法可以一次性地读取所有数据，并返回将每行数据作为元素封装的数组。
  ```ruby
  ary = io.readlines
  ary.each_line do |line|
    line.chomp!
    …  # 对line 进行的操作
  end
  ```

> **备注**：gets 方法与 puts 方法分别是“get string”“put string”的意思。

- `io.lineno`, `io.lineno=(number)`：使用 gets 方法、 each_line 方法逐行读取数据时，会自动记录读取的行数。这个行数可以通过 lineno 方法获取。此外，通过 lineno= 方法也可以改变这个值，但值的改变并不会对文件指针（后述）产生影响。

- `io.each_char`：逐个字符地读取io 中的数据并执行块，将读取的字符（ String 对象）作为块变量传递。

- `io.each_byte`：逐个字节地读取io 中的数据并启动块，将读取到的字节所对应的ASCII 码以整数值的形式传递给块变量。

- `io.getc`：只读取io 中的一个字符。根据文件编码的不同，有时一个字符会由多个字节组成，但这个方法只会读取一个字符，然后返回string 对象。数据全部读取完后，再读取时会返回 nil。

- `io.ungetc(ch)`：将参数 ch 指定的字符退回到 io 的输入缓冲区中。

- `io.getbyte`：只读取 io 中的一个字节，以整数对象返回与得到的字节相对应的ASCII 码。数据全部读取完后，再读取时会返回 nil。

- `io.ungetbyte(byte)`：将参数byte 指定的一个字节退回到输入缓冲区中。参数为整数时，将该整数除以256 后的余数作为ASCII 码返回一个字节；参数为字符串时，只返回字符串的第一个字节。

- `io.read(size)`：读取参数size 中指定的大小的数据。不指定大小时，则一次性读取全部数据并返回

### 17.2.2 输出操作

- `io.puts(str0, str1, …)`：在字符串末尾添加换行符后输出。指定多个参数时，会分别添加换行符。如果参数为 String 类以外的对象，则会调用 to_s 方法，将其转换为字符串后再输出。

- `io.putc(ch)`：输出参数ch 指定的字符编码所对应的字符，参数为字符串时输出首字符。

- `io.print(str0, str1, …)`输出参数指定的字符串。参数可指定多个字符串。参数为 String 以外的对象时会自动将其转换为字符串。

- `io.printf(fmt, arg0, arg1, …)`：按照指定的格式输出字符串。格式fmt 的用法与 printf 方法一样。

> **参考**：第14 章专栏 “printf 方法与sprintf 方法”

“printf 方法与sprintf 方法”。

- `io.write(str)`：输出参数str 指定的字符串。参数为 String 以外的对象时会自动将其转换为字符串。返回值为写入的字节数。

p size #=> 6

- `io<<str`：输出参数str 指定的字符串。 << 会返回接收者本身。

## 17.3 文件指针

一般情况下，我们会以行为单位来处理文本数据。由于只有当读取到换行符时才能知道行的长度，因此，比如要读取第100 行的数据，就要将这100 行的数据全部读取。另外，如果我们修改了数据，行的长度也会随之变更，这样一来，文件中后面的数据就都要进行修改。为了提高读取效率，可以将文件分成固定长度的文件块，来直接访问某个位置的数据（虽然

据此可以访问任意位置的数据，但却不能处理超过指定长度的数据）。我们用**文件指针（file pointer）**或者**当前文件偏移量（current file offset）**来表示 IO 对象指向的文件的位置。每当读写文件时，文件指针都会自动移动，而我们也可以使文件指针指向任意位置来读写数据。

- `io.pos`, `io.pos=(position)`：通过 pos 方法可以获得文件指针现在的位置。改变文件指针的位置用 pos= 方法。

- `io.seek(offset, whence)`：移动文件指针的方法。参数offset 为用于指定位置的整数，参数whence 用于指定 offset 如何移动：

  | whence | 意义 |
  | -- | -- |
  | IO::SEEK_SET | 将文件指针移动到offset 指定的位置 |
  | IO::SEEK_CUR | 将offset 视为相对于当前位置的偏移位置来移动文件指针 |
  | IO::SEEK_END | 将offset 指定为相对于文件末尾的偏移位置 |

- `io.rewind`：将文件指针返回到文件的开头。 lineno 方法返回的行编号为0。

- `io.truncate(size)`：按照参数size 指定的大小截断文件。

## 17.4 二进制模式与文本模式

正如我们在第 14 章的专栏“关于换行符”中介绍的那样，不同平台下的换行符也不同。

虽然各个平台的换行符不一样，但为了保证程序的兼容性，会将字符串中的 "\n" 转换为当前 OS 的换行符并输出。此外，在读取时也会将实际的换行符转换为 "\n" 。

在Windows 以外的平台中，如果将File.open 方法的模式指定为"rt" 或"wt"，或者设定选项textmode: true，读取时就会把换行符CR、LF、CR + LF 都转换为LF ；写入时则会按照平台标准文本文件的格式，把LF 转换为对应的换行符。如果是Windows 环境，则转换为CR + LF，如果是Linux、Mac OS X 环境，则直接输出LF。当需要确定文件大小进行输入/ 输出处理时，或者直接使用从其他平台复制的文件时，如果转换换行符，就有可能会引发问题。

为了解决上述问题，Ruby 中还提供了不进行换行符转换的方法。转换换行符的前提是以行为单位进行输入/ 输出，能够进行转换的状态称为文本模式，反之不能够进行转换的状态则称为二进制模式。

- `io.binmode`：新的 IO 对象默认是文本模式，使用 binmode 方法可将其变更为二进制模式。

  ```ruby
  File.open("foo.txt", "w") do |io|
    io.binmode
    io.write "Hello, world.\n"
  end
  ```

这样就可以在不转换换行符的情况下得到与文件中一模一样的数据。

> **备注**：转换为二进制模式的 IO 对象无法再次转换为文本模式。

## 17.5 缓冲

即使对 IO 对象进行写入，结果也并不一定马上就会反映在控制台或者文件中。在使用 write、print 等方法操作 IO 对象时，程序内部会开辟出一定的空间来保存临时生成的数据副本。这部分空间就称为**缓冲区（buffer）**。缓冲区里累积一定量的数据后，就会进行输出处理，然后清空缓冲区。

像这样，使用临时缓冲区进行数据处理称为缓冲（buffering），程序并不是在调用write 方法时写入文件，而是在完成所有写入操作并关闭文件后才最终将数据写入文件。文件写入会产生磁盘写入，所以是一个耗费资源的操作。我们的最终目的是把数据写入文件，在这个前提下，也要尽量减少写入操作的次数。

有时我们会希望输出的数据马上被其他程序使用，下面就来看一下立即写入文件的方法。

- `io.flush`：调用这个方法后会立即输出输出缓冲区中的数据。

- `io.sync`, `io.sync=(state)`：sync 是 synchronize（同步）的意思。指定 io.sync = true 后，程序会同步进行写入操作。这样一来，即使不调用 flush 方法，也能得到同样的结果。

## 17.6 与命令进行交互

虽然Ruby 是几乎什么都能实现的强大语言，但有时也会使用其他命令进行数据处理。例如，读取使用GUN zip 压缩的数据时，使用zcat 命令会很方便。

在Ruby 中，使用 IO.popen 方法可以与其他命令进行数据的交互。

- `IO.popen(command, mode)`

  参数mode 的使用方法与 File.open 方法是一样的，参数缺省时默认为 "r" 模式。

  用 IO.popen 方法生成的 IO 对象的输入/ 输出，会关联启动的命令command 的标准输入/输出。也就是说， IO 对象的输出会作为命令的输入，命令的输出则会作为 IO 对象的输入。

- `open("|command", mode)`：将带有管道符号的命令传给 open 方法的效果与使用 IO.popen 方法是一样的。

## 17.7 open-uri 库

除了控制台、文件以外，进程间通信时使用的管道、网络间通信时使用的套接字也都可以作为 IO 对象使用。管道、套接字的使用方法超出了本书的范围，因此不详细说明，这里我们简单地介绍一下利用HTTP、FTP 从网络获取数据的方法。

通过 require 引用 open-uri 库后，我们就可以像打开普通的文件一样打开HTTP、FTP 的 URL。

```ruby
require "open-uri"

# 通过HTTP 读取数据
open("http://www.ruby-lang.org/zh_cn/") do |io|
  puts io.read # 将Ruby 的官方网页输出到控制台
end

# 通过FTP 读取数据
filename = "ruby-2.3.0.tar.gz"
url = "ftp://www.ruby-lang.org/pub/ruby/2.3/#{filename}"
open(url) do |io|
  File.binwrite(filename, io.read) # 写入文件
end
```

## 17.8 stringio 库

在测试程序时，虽然我们希望知道向文件或控制台输出了什么，但程序实际执行的结果却往往很难知道。为此，可以通过向模拟 IO 对象的对象进行输出来确认执行结果。

StringIO 就是用于模拟 IO 对象的对象。通过 require 引用 stringio 库后，就可以使用 StringIO 对象了。

```ruby
io = StringIO.new

io.puts("A")
io.puts("B")
io.puts("C")

io.rewind
p io.read #=> "A\nB\nC\n"
```

实际上，向 StringIO 对象进行的输出并不会被输出到任何地方，而是会被保存在对象中，之后就可以使用 read 方法等来读取该输出。

StringIO 对象还有另外一种用法，那就是将字符串数据当作 IO 数据处理。在将大数据保存在文件中，将小数据直接传输给别的处理的情况下，通过使用 StringIO 对象，程序就可以不区分对待 IO 对象和字符串了。实际上，用之前介绍的 open-uri 库打开URI 时，也是有时返回 IO 对象，有时返回 StringIO 对象。不过一般情况下，我们不需要在意这两者的区别。

通过将数据字符串传递给 StringIO.new 方法的参数，就可以由字符串创建 StringIO 对象。

```ruby
require "stringio"

io = StringIO.new("A\nB\nC\n")

p io.gets #=> "A\n"
p io.gets #=> "B\n"
p io.gets #=> "C\n"
```

StringIO 对象可以模拟本章中介绍的大部分输入/ 输出操作。
