# 第13章 数组类
---

[TOC]

## 13.1 复习数组

数组的定义：**数组是带索引的对象的集合。**

数组有以下特征：
- 可以从数组中获取某个索引的元素（对象）
- 可以将任意的值（对象）保存到数组的某个索引的元素中
- 使用迭代器可以逐个取出数组中的元素

## 13.2 数组的创建

在第二章中，我们介绍了使用 `[]` 来创建数组的方法，除此之外还有其他的创建方法。
```ruby
nums = [1, 2, 3, 4, 5]
```

### 13.2.1 使用  `Array.new`

Array类下，若new方法没有参数则创建个数为0的数组；
若有一个参数，创建有给定数量，值为 nil 的数组；
若有二个参数，则创建给定数量的，值为给定参数的数组；
```ruby
a = Array.new              #=> []
a = Array.new(5)           #=> [nil, nil, nil, nil, nil]
a = Array.new(5, 0)        #=> [0, 0, 0, 0, 0]
```

### 13.2.2 使用 `%w` 与 `%i`

创建不含空白的字符串可以使用 `%w`
```ruby
lang = %w(Ruby Python Scheme Pike REBOL)                        #=> ["Ruby", "Python", "Scheme", "Pike", "REBOL"]
```
创建元素为符号的数组时，可以使用 `%i`
```ruby
lang = %i(Ruby Python Scheme Pike REBOL)                        #=> [:Ruby, :Python, :Scheme, :Pike, :REBOL]
```

在本例中，创建数组时使用 () 将数组元素括了起来，但实际上还可以使用如 <> 、 || 、 !! 、@ @、 % % 等任意字符。

> **建议**：虽然允许我们使用任意字符，但若用一些不常用的字符来创建数组的话，可能就会使程序不便于阅读。在选择表示字符串数组元素的字符时，还要注意该字符不能在要创建的字符串中出现，因此建议使用 () 、 <> 、 || 。

### 13.2.3 使用 `to_a` 方法
很多类都定义了 to_a 方法，该方法能把该类的对象转换为数组。
```ruby
color_table = {black: "#000000", white: "#FFFFFF"}
p color_table.to_a                                              #=> [{:black, "#000000", white: "#FFFFFF"}, {:white, "#FFFFFF"}]
```

### 13.2.4 使用字符串的 `split` 方法
```ruby
column = "2016/02/01, fool.html, proxy.example.jp".split(',')
p column                                                        #=> ["2016/02/01", "fool.html", "proxy.example.jp"]
```

## 13.3 索引的使用方法

### 13.3.1 获取元素

通过 `[]` 指定索引，获取元素有如下三种方法：
1. `a[n]`
    获取给定索引的值（索引从0开始），若索引为负数则从末尾开始获取元素，索引超限则返回 nil

2. `a[n..m]` 或者 `a[n....m]`
    获取从 n 到 m 元素（[n...m]表示从 n 到 m-1）的值，如果 m 的值大于数组长度，则多余部分不返回

3. `a[n, len]`
    获取中 n 开始的 len 数量的值。

另外，我们还可以使用方法代替 `[]`：
- `a.at(n)` 等价于 `a[n]`
- `a.slice(n)` 等价于 `a[n]`
- `a.slice(n..m)` 等价于 `a[n..m]`
- `a.slice(n, len)` 等价于 `a[n, len]`

### 13.3.2 替换元素
使用[ ]、 a t、 s lice 方法除了可以获取元素外，还可以替换元素。
- **`a[n] = item`**：这是将a[n] 的元素值变更为item。

实际上Ruby 还可以一次替换多个元素。指定多个元素的方法与上面获取多个元素的方法是一样的。
```ruby
alpha = ["a", "b", "c", "d", "e", "f"]
alpha[2, 3] = ["C", "D", "E"]
p alpha #=> ["a", "b", "C", "D", "E", "f"]
```

### 13.3.3 插入元素
我们还可以在保持当前元素不变的情况下，在数组中插入新的元素。

插入元素其实也可以被认为是替换 0 个元素。因此，指定 [n, 0] 后，就会在索引值为 n 的元素前插入新元素
```ruby
alpha = ["a","b","c","d","e","f"]
alpha[2, 0] = ["X","Y"]
p alpha #=> ["a", "b", "X", "Y", "c", "d", "e", "f"]
```

### 13.3.4 通过多个索引创建数组
使用 `values_at` 方法，可以利用多个索引来获取多个分散的元素，并用它们创建新数组。
- `a.values_at (n1, n2, …)`
```ruby
alpha = %w(a b c d e f)
p alpha.values_at(1,3,5) #=> ["b", "d", "f"]
```

## 13.4 作为集合的数组
我们可以把数组当成集合，这样一来， Array 类中的各元素就变了集合中的元素。由于集合没有顺序的概念，因此 ["a", "b", "c"] 、 ["b", "c", "a"] 、 ["c", "b", "a"] 就都可以被认为是同一个集合。

这样操作数组时，如果我们还关心“这个对象是数组的第几个元素”之类的问题，就可能会造成混乱。这是因为，索引操作实际上只是数组封装的一个功能而已。

### 13.4.1 集合的运算
集合的基本运算分为交集和并集。
- 取出同时属于两个集合的元素，并创建新的集合
- 取出两个集合中的所有元素，并创建新的集合

我们把第 1 种集合称为交集，第 2 种集合称为并集。
- 交集：`ary = ary1 & ary2`
- 并集：`ary = ary1 | ary2`

集合还有另外一种运算——补集，即获取某个集合中不属于另外一个集合的元素。但是 Array 类的情况下，由于没有全集的概念，因此也就没有补集。不过 Array 类有把某个集合中属于另外一个集合的元素删除的差运算
- 集合的差：`ary = ary1 - ary2`

### 13.4.2  “|” 与 “+” 的不同点
连接数组除了可以使用 | 外还可以使用 + 。这两种方法看起来比较相似，但是有相同元素时它们的效果就不一样了。使用 + 时相同元素可以重复添加，使用 | 时则相同的元素只会有一个。
```ruby
num = [1, 2,3]
even = [2, 4, 6]
p (num + even) #=> [1, 2, 3, 2, 4, 6]
p (num | even) #=> [1, 2, 3, 4, 6]
```

## 13.5 作为列的数组

数据结构的**队列**（queue）和**栈**（stack）都是典型的列结构。两种数据结构都有以下两种操作数据的方式：
- 追加元素
- 读取元素

名词解释
- **队列**是一种按元素被追加时的顺序来获取元素的数据结构。这样的做法称为FIFO（First-in First-out），也就是“先进先出”的意思。这与人们为等待某件事而排成一列的情况一样，因此有时也称为等待队列。
- **栈**是一种按照与元素被追加时的顺序相反的顺序来获取元素的数据结构。这样的做法称为LIFO（Last-in First-out），是一种“先进后出”的数据结构。也就是说，在末尾追加元素，并从末尾开始获取元素。

队列与栈都是比较复杂的数据结构，同时也是提高程序运行效率所不可欠缺的工具。

在数组的开头或末尾插入元素，或者从数组的开头或末尾获取元素等操作，是实现队列、栈等数据结构的前提条件。Ruby 的数组封装了如下方法，因此可以很轻松地实现这些前提条件。
| - | 对数组开头的元素的操作 | 作对数组末尾的元素的操作 |
| -- | -- | -- |
| 追加元素  | unshift | push |
| 删除元素  | shift | pop |
| 引用元素  | first | last |

需要注意的是， shift 方法和 pop 方法不只是获取数组元素，而且还会把该元素从数组中删除。如果只是单纯地希望引用元素，则应该使用 first 方法和 last 方法。

## 13.6 数组的主要方法

### 13.6.1 为数组添加元素

- `a.unshift (item)`：将item 元素添加到数组的开头。
- `a << item`,`a.push (item)`：<< 与 push 是等价的方法，在数组a 的末尾添加新元素item。
- `a.concat (b)`,`a + b`：连接数组a 和数组b。 concat 是具有破坏性的方法，而 + 则会根据原来的数组元素创建新的数组。
- `a[n] = item`,`a[n..m] = item`,`a[n, len] = item`：把数组a 指定的部分的元素替换为item。

### 专栏：具有破坏性的方法
像 pop 方法、 shift 方法那样，会改变作为接收者的对象的值的方法称为**具有破坏性的方法**。在使用具有破坏性的方法时需要特别小心，因为当有变量也引用了接收者对象时，如果接收者对象值发生了改变，变量值也会随之发生变化。

我们可以使用 `Object#freeze` 方法禁止具有破坏性的方法修改对象内容。调用这个方法后，对象就会被冻结，如果其内容被变更了，就会抛出错误。虽然冻结后对象无法解冻，但可以使用 dup 方法，得到未冻结的对象副本。

```ruby
a = [1, 2, 3, 4]
a.freeze
b = a.dup
p a.pop #=> in `pop': can't modify frozen Array (RuntimeError)
p b.pop #=> 4
```
在Ruby 的方法中，有像 sort 和 sort! 这样的在相同方法名后加上 ! 的方法。为了区分方法是否具有破坏性，在具有破坏性的方法末尾添加! 的做法目前已经成为了通用的规则。

### 13.6.2 从数组中删除元素

- `a.compact`,`a.compact!`：从数组 a 中删除所有 nil 元素。 compact 方法会返回新的数组； compact! 则直接替换原来的数组，如果什么都没有删除的话就会返回 nil。
- `a.delete(x)`：从数组a 中删除x 元素。
- `a.delete_at(n)`：从数组中删除a[n] 元素。
- `a.delete_if{|item| … }`,`a.reject{|item| … }`,`a.reject!{|item| … }`：关于数组 a 中的各元素 item，如果块的执行结果为真，则从数组 a 中删除 item。 delete_if 和 reject! 方法都是具有破坏性的方法。
- `a.slice!(n)`,`a.slice!(n..m)`,`a.slice!(n, len)`：删除数组 a 中指定的部分，并返回删除部分的值。 slice! 是具有破坏性的方法。
- `a.uniq`,`a.uniq!`：删除数组a 中重复的元素。 uniq! 是具有破坏性的方法。
- `a.shift`：删除数组a 的开头元素，并返回删除的值。
- `a.pop`：删除数组a 的末尾元素，并返回删除的值。


### 13.6.3 替换数组元素
- `a.collect{|item| … }`,`a.collect!{|item| … }`,`a.map{|item| … }`,`a.map!{|item| … }`：将数组a 的各元素item 传给块，并用块处理过的结果创建新的数组。从结果来看，虽然数组的元素个数不变，但由于经过了块处理，因此数组的元素会和之前不一样。
- `a.fill(value)`,`a.fill(value, begin)`,`a.fill(value, begin, len)`,`a.fill(value, n..m)`：将数组a 的元素替换为value。只有1 个参数时，数组a 的所有元素值都会变为value。有2 个参数时，从begin 到数组末尾的元素值都会变为value。有3 个参数时，从begin 开始的len 个元素的值会变为value。另外，当第2 个参数指定为[n..m] 时，则指定范围内的元素值都会变为value。
- `a.flatten`,`a.flatten!`：平坦化数组a。所谓平坦化是指展开嵌套数组，使嵌套数组变成一个大数组。
- `a.reverse`,`a.reverse!`：反转数组a 的元素顺序。
- `a.sort`,`a.sort!`,`a.sort{|i, j| … }`,`a.sort!{|i, j| … }`：对数组 a 进行排序，排序方法可以由块指定。没有块时，使用 <=> 运算符进行比较。
- `a.sort_by{|i| … }`：对数组 a 进行排序。根据块的运行结果对数组的所有元素进行排序。


## 13.7 数组与迭代器
迭代器是实现循环处理的方法，而数组则是多个对象的集合。在对这些对象进行某种处理，或者取出某几个对象时，都需要大量用到迭代器。例如，对数组的各元素进行相同的操作时使用的 each 方法就是典型的迭代器。

此外，接收者不是数组时，为了让迭代器的执行结果能作为某个对象返回，也会用到数组。collect 方法就是其中一个具有代表性的方法。 collect 方法会收集某种处理的结果，并将其合并为一个数组后返回。
```ruby
a = 1..5
b = a.collect{|i| i += 2}
p b #=> [3, 4, 5, 6, 7]
```

## 13.8 处理数组中的元素
对数组中的元素进行处理时可以采取多种方法。

### 13.8.1 使用循环与索引
传统的方法是使用循环，也就是在遍历数组的同时，利用索引逐个访问数组元素。

### 13.8.2 使用 each 方法逐个获取元素
在数组中，通过 each 方法可以实现循环操作。
```ruby
list = [1, 3, 5, 7, 9]
sum = 0
list.each do |elem|
sum += elem
end
print " 合计：",sum,"\n"
```

但是，使用 each 方法时，我们并不知道元素的索引值。因此，当需要指定元素的索引值时，可以使用 each_with_index 方法
```ruby
list = ["a", "b", "c", "d"]
list.each_with_index do |elem, i|
print " 第", i+1," 个元素是",elem,"。\n"
end
```

### 13.8.3 使用具有破坏性的迭代器
如果数组内各元素全部处理完毕后就不需要该数组了，那么我们就可以通过逐个删除数组元素使数组变空这一方法来实现循环。
```ruby
while item = a.pop
## 对item 进行处理
end
```
### 13.8.4 使用其他迭代器
Ruby中实现了不少像 collect、 map 方法这样一眼就能看出其作用的基本操作。当希望创建某种迭代器时，请翻阅Ruby 参考手册，一般情况下在里面都能找到我们需要的迭代器，这样就不会因为花精力创建了一个 Ruby 本来就有的迭代器而感到失望了。

### 13.8.5 创建专用的迭代器
不过有时也可能会找不到自己想要的迭代器，这时就只能根据需要创建属于自己的迭代器了。
> 关于迭代器的创建，请参考 11.3 节。

## 13.9 数组的元素
数组中可以存放各种各样的对象。除了数值、字符串外，我们还可以在数组对象中存放别的数组对象或散列对象等。

### 13.9.1 使用简单的矩阵
数组的各个元素也可以是数组，也就是所谓的数组的数组，这样的形式经常被用于表示矩阵。

### 13.9.2 初始化时的注意事项
把数组对象或者散列对象作为数组元素时，需要注意该对象初始化时的问题。
```ruby
a = Array.new(3, [0, 0, 0])
```

在上面的例子中，我们可能会以为 a 为 [[0, 0, 0], [0, 0, 0], [0, 0, 0]] ，但实际并非如此。a[0]、a[1]、a[2] 实际上都指向同一个对象。


为了解决这个问题，我们可以指定 new 方法的块和元素个数。程序调用与元素个数一样数量的块，然后再将块的返回值赋值给元素。每次调用块时都会生成新的对象，这样一来，就不会发生各个元素引用同一个对象的问题了。
```ruby
a = Array.new(3) do
[0, 0, 0]
end
p a #=> [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
a[0][1] = 2
p a #=> [[0, 2, 0], [0, 0, 0], [0, 0, 0]]
```

## 13.10 同时访问多个数组
接下来我们来看看用相同的索引值同时访问多个数组时的情况。计算三个数组中索引值相同的元素的合计值，并将结果保存在新数组（result）中，可以使用 zip 方法，以使程序变得更简单。
```ruby
ary1 = [1, 2, 3, 4, 5]
ary2 = [10, 20, 30, 40, 50]
ary3 = [100, 200, 300, 400, 500]
result = []
ary1.zip(ary2, ary3) do |a, b, c|
result << a + b + c
end
p result #=> [111, 222, 333, 444, 555]
```

zip 方法会将接收者和参数传来的数组元素逐一取出，而且每次都会启动块。参数可以是一个也可以是多个。

### 专栏：Enumerable 模块
介绍完 Comparable 模块后，我们再来介绍一下经常被用于 Mix-in 的 Enumerable 模块。Enumerable 的意思是“可数的”“可列举的”。在本书介绍过的类中，Array、Dir、 File、Hash、 IO、 Range、 Enumerator 等类中都包含了Enumerable 模块。

| 方法 | 意义 |
| -- | -- |
| all? | 所有元素为真时返回true，否则返回 false |
| any? | 一个或以上的元素为真时返回 true，否则返回 false
| collect | 把各元素的块执行结果以数组的形式返回 |
| count | 不指定参数时返回所有元素的数量，指定参数时则返回与参数值一样的元素数量 |
| cycle | 对各元素循环（最后一个执行完后返回首个元素再）执行块处理 |
| detect | 对元素进行块处理，当结果为真时返回首个元素 |
| each_slice | 指定参数n，n 个元素为1 组，把各组元素传给块执行 |
| each_with_index | 把元素及其索引传给块执行 |
| find | 与detect 等价 |
| find_all | 把所有元素传给块执行，以数组的形式返回结果为真的元素 |
| first | 获取首个元素 |
| grep | 匹配参数指定的模式，得到的元素以数组形式返回 |
| include? | 如果包含参数指定的值则返回真 |
| inject | 对元素进行块的叠加运算并返回结果 |
| map | 与collect 等价 |
| member? | 与include? 等价 |
| none? | 所有元素为假时返回 true，否则返回 false |
| one? | 有且只有一个元素为真时返回 true，否则返回 false |
| partition | 把块的执行结果为真的放在一个数组里，为假的放在另外一个数组里，并返回这两个数组 |
| reduce | 与 inject 等价 |
| reject | 把所有元素传给块执行，以数组的形式返回结果为假的元素 |
| reverse_each | 倒序执行各元素的块运算 |
| select | 与 find_all 等价 |
| sort | 对块的执行结果排序后以数组形式返回 |
| sort_by | 对块的执行结果用<=> 比较后进行排序，然后以数组的形式返回 |
| to_a | 把所有元素以数组的形式返回 |
| zip | 把接收者和参数对应的各元素合并为1 个元素后以数组的形式返回 |

在本章介绍的 Array 类的方法中，实际上有些是在 Enumerable 模块中定义的。关于上文中没有介绍的方法的用法，请参考Ruby 参考手册。
就像 Comparable 模块需要 <=> 运算符那样， Enumerable 模块则需要 each 方法。

例如，如果用Ruby 来实现 each_with_index 方法的话，大概就是下面这样（实际的程序会更加复杂，例如没有块时会返回 Enumerator 对象等）。
```ruby
module Enumerable
  def each_with_index
    index = 0              # 初始化索引
    each do |item|
      yield(item, index)   # 将元素与index 作为参数
                           # 执行块
      index += 1           # 累加索引值
    end
  end
end
```

我们在创建提供循环处理的类时，可以首先将 each 方法创建成迭代器，然后再包含 Enumerable 模块，这样一来，上表的方法就都可以使用了。
